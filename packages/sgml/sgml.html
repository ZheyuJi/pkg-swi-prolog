<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>SWI-Prolog SGML/XML parser</TITLE><STYLE type="text/css">
/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

dt.multidef
{ background-color: #c8ffc7;
}

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{
}

span.sec-title
{
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
padding-top: 0.2em;
font-size: 80%;
font-style: italic;
color: #202020;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text { display: none; }
sup.fn span {display: none;}
sup:hover span
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}
</STYLE>
</HEAD>
<BODY BGCOLOR="white"> 

<P>
<DIV class="title">SWI-Prolog SGML/XML parser</DIV>
<DIV class="author">Jan Wielemaker <BR>
HCS, <BR>
University of Amsterdam <BR>
The Netherlands <BR>
E-mail: <A class="url" href="mailto:J.Wielemaker@uva.nl">J.Wielemaker@uva.nl</A></DIV>
<DIV class="abstract">
<DIV class="abstract-title">Abstract</DIV> Markup languages are an 
increasingly important method for data-representation and exchange. This 
article documents the package
<CODE>library(sgml)</CODE>, a foreign library for SWI-Prolog to parse 
SGML and XML documents, returning information on both the document and 
the document's DTD. The parser is designed to be small, fast and 
flexible.
</DIV>

<H1><A NAME="document-contents">Table of Contents</A></H1>

<DIV class="toc">
<DIV class="toc-h2"><A class="sec" href="#sec:1"><SPAN class="sec-nr">1</SPAN> <SPAN class="sec-title">Introduction</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:2"><SPAN class="sec-nr">2</SPAN> <SPAN class="sec-title">Bluffer's 
Guide</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:2.1"><SPAN class="sec-nr">2.1</SPAN> <SPAN class="sec-title">`Goodies' 
Predicates</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:3"><SPAN class="sec-nr">3</SPAN> <SPAN class="sec-title">Predicate 
Reference</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:3.1"><SPAN class="sec-nr">3.1</SPAN> <SPAN class="sec-title">Loading 
Structured Documents</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:3.2"><SPAN class="sec-nr">3.2</SPAN> <SPAN class="sec-title">Handling 
white-space</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:3.3"><SPAN class="sec-nr">3.3</SPAN> <SPAN class="sec-title">XML 
documents</SPAN></A></DIV>
<DIV class="toc-h4"><A class="sec" href="#sec:3.3.1"><SPAN class="sec-nr">3.3.1</SPAN> <SPAN class="sec-title">XML 
Namespaces</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:3.4"><SPAN class="sec-nr">3.4</SPAN> <SPAN class="sec-title">DTD-Handling</SPAN></A></DIV>
<DIV class="toc-h4"><A class="sec" href="#sec:3.4.1"><SPAN class="sec-nr">3.4.1</SPAN> <SPAN class="sec-title">The 
DOCTYPE declaration</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:3.5"><SPAN class="sec-nr">3.5</SPAN> <SPAN class="sec-title">Extracting 
a DTD</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:3.6"><SPAN class="sec-nr">3.6</SPAN> <SPAN class="sec-title">Parsing 
Primitives</SPAN></A></DIV>
<DIV class="toc-h4"><A class="sec" href="#sec:3.6.1"><SPAN class="sec-nr">3.6.1</SPAN> <SPAN class="sec-title">Partial 
Parsing</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:3.7"><SPAN class="sec-nr">3.7</SPAN> <SPAN class="sec-title">Type 
checking</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:4"><SPAN class="sec-nr">4</SPAN> <SPAN class="sec-title">Stream 
encoding issues</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:5"><SPAN class="sec-nr">5</SPAN> <SPAN class="sec-title">library(xpath): 
Select nodes in an XML DOM</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:6"><SPAN class="sec-nr">6</SPAN> <SPAN class="sec-title">Processing 
Indexed Files</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:7"><SPAN class="sec-nr">7</SPAN> <SPAN class="sec-title">External 
entities</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:8"><SPAN class="sec-nr">8</SPAN> <SPAN class="sec-title">library(pwp): 
Prolog Well-formed Pages</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:9"><SPAN class="sec-nr">9</SPAN> <SPAN class="sec-title">Writing 
markup</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:9.1"><SPAN class="sec-nr">9.1</SPAN> <SPAN class="sec-title">Writing 
documents</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:9.2"><SPAN class="sec-nr">9.2</SPAN> <SPAN class="sec-title">XML 
Quote primitives</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:10"><SPAN class="sec-nr">10</SPAN> <SPAN class="sec-title">Unsupported 
features</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:11"><SPAN class="sec-nr">11</SPAN> <SPAN class="sec-title">Installation</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:11.1"><SPAN class="sec-nr">11.1</SPAN> <SPAN class="sec-title">Unix 
systems</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:12"><SPAN class="sec-nr">12</SPAN> <SPAN class="sec-title">Acknowledgements</SPAN></A></DIV>
</DIV>

<P>

<H2><A NAME="sec:1"><SPAN class="sec-nr">1</SPAN> <SPAN class="sec-title">Introduction</SPAN></A></H2>

<P>Markup languages have recently regained popularity for two reasons. 
One is document exchange, which is largely based on HTML, an instance of 
SGML, and the other is for data exchange between programs, which is 
often based on XML, which can be considered a simplified and 
rationalised version of SGML.

<P>James Clark's SP parser is a flexible SGML and XML parser. 
Unfortunately it has some drawbacks. It is very big, not very fast, 
cannot work under event-driven input and is generally hard to program 
beyond the scope of the well designed generic interface. The generic 
interface however does not provide access to the DTD, does not allow for 
flexible handling of input or parsing the DTD independently of a 
document instance.

<P>The parser described in this document is small (less than 100 kBytes 
executable on a Pentium), fast (between 2 and 5 times faster than SP), 
provides access to the DTD, and provides flexible input handling.

<P>The document output is equal to the output produced by <EM>xml2pl</EM>, 
an SP interface to SWI-Prolog written by Anjo Anjewierden.

<H2><A NAME="sec:2"><SPAN class="sec-nr">2</SPAN> <SPAN class="sec-title">Bluffer's 
Guide</SPAN></A></H2>

<P>This package allows you to parse SGML, XML and HTML data into a 
Prolog data structure. The high-level interface defined in <CODE>library(sgml)</CODE> 
provides access at the file-level, while the low-level interface defined 
in the foreign module works with Prolog streams. Please use the source 
of <CODE>sgml.pl</CODE> as a starting point for dealing with data from 
other sources than files, such as SWI-Prolog resources, network-sockets, 
character strings, <EM>etc.</EM> The first example below loads an HTML 
file.

<PRE class="code">
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;

&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Demo&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 align=center&gt;This is a demo&lt;/title&gt;

Paragraphs in HTML need not be closed.

This is called `omitted-tag' handling.
&lt;/body&gt;
&lt;/html&gt;
</PRE>

<PRE class="code">
?- load_html_file('test.html', Term),
   pretty_print(Term).

[ element(html,
          [],
          [ element(head,
                    [],
                    [ element(title,
                              [],
                              [ 'Demo'
                              ])
                    ]),
            element(body,
                    [],
                    [ '\n',
                      element(h1,
                              [ align = center
                              ],
                              [ 'This is a demo'
                              ]),
                      '\n\n',
                      element(p,
                              [],
                              [ 'Paragraphs in HTML need not be closed.\n'
                              ]),
                      element(p,
                              [],
                              [ 'This is called `omitted-tag\' handling.'
                              ])
                    ])
          ])
].
</PRE>

<P>The document is represented as a list, each element being an atom to 
represent <CODE>CDATA</CODE> or a term <CODE>element(Name, Attributes, 
Content)</CODE>. Entities (e.g. <CODE>&amp;lt;</CODE>) are expanded and 
included in the atom representing the element content or attribute 
value.<SUP class="fn">1<SPAN class="fn-text">Up to SWI-Prolog 5.4.x, 
Prolog could not represent <EM>wide</EM> characters and entities that 
did not fit in the Prolog characters set were emitted as a term <CODE>number(+Code)</CODE>. 
With the introduction of wide characters in the 5.5 branch this is no 
longer needed.</SPAN></SUP>

<H3><A NAME="sec:2.1"><SPAN class="sec-nr">2.1</SPAN> <SPAN class="sec-title">`Goodies' 
Predicates</SPAN></A></H3>

<P>These predicates are for basic use of the library, converting entire 
and self-contained files in SGML, HTML, or XML into a structured term. 
They are based on <A NAME="idx:loadstructure3:1"></A><A class="pred" href="#load_structure/3">load_structure/3</A>.

<DL class="latex">
<DT class="pubdef"><A NAME="load_sgml_file/2"><STRONG>load_sgml_file</STRONG>(<VAR>+Source, 
-ListOfContent</VAR>)</A></DT>
<DD class="defbody">
Same as <CODE>load_structure(Source, ListOfContent, [dialect(sgml)])</CODE>.</DD>
<DT class="pubdef"><A NAME="load_xml_file/2"><STRONG>load_xml_file</STRONG>(<VAR>+Source, 
-ListOfContent</VAR>)</A></DT>
<DD class="defbody">
Same as <CODE>load_structure(Source, ListOfContent, [dialect(xml)](load_structure(Source, 
ListOfContent, [dialect(xml)])</CODE></DD>
<DT class="pubdef"><A NAME="load_html_file/2"><STRONG>load_html_file</STRONG>(<VAR>+Source, 
-Content</VAR>)</A></DT>
<DD class="defbody">
Load <VAR>Source</VAR> and parse as HTML. <VAR>Source</VAR> is either 
the name of a file or term <CODE>stream(Handle)</CODE>. Implemented as 
below. Note that <A NAME="idx:loadhtmlfile2:2"></A><A class="pred" href="#load_html_file/2">load_html_file/2</A> 
re-uses a cached DTD object as defined by <A NAME="idx:dtd2:3"></A><A class="pred" href="#dtd/2">dtd/2</A>. 
As DTD objects may be corrupted while loading errornous documents 
sharing is undesirable if the documents are not known to be correct. See <A NAME="idx:dtd2:4"></A><A class="pred" href="#dtd/2">dtd/2</A> 
for details.

<PRE class="code">
load_html_file(Source, Term) :-
        dtd(html, DTD),
        load_structure(Source, Term,
                       [ dtd(DTD),
                         dialect(sgml),
                         shorttag(false)
                       ]).
</PRE>

<P></DD>
</DL>

<H2><A NAME="sec:3"><SPAN class="sec-nr">3</SPAN> <SPAN class="sec-title">Predicate 
Reference</SPAN></A></H2>

<H3><A NAME="sec:3.1"><SPAN class="sec-nr">3.1</SPAN> <SPAN class="sec-title">Loading 
Structured Documents</SPAN></A></H3>

<P>SGML or XML files are loaded through the common predicate
<A NAME="idx:loadstructure3:5"></A><A class="pred" href="#load_structure/3">load_structure/3</A>. 
This is a predicate with many options. For simplicity a number of 
commonly used shorthands are provided:
<A NAME="idx:loadsgmlfile2:6"></A><A class="pred" href="#load_sgml_file/2">load_sgml_file/2</A>, <A NAME="idx:loadxmlfile2:7"></A><A class="pred" href="#load_xml_file/2">load_xml_file/2</A>, 
and
<A NAME="idx:loadhtmlfile2:8"></A><A class="pred" href="#load_html_file/2">load_html_file/2</A>.

<DL class="latex">
<DT class="pubdef"><A NAME="load_structure/3"><STRONG>load_structure</STRONG>(<VAR>+Source, 
-ListOfContent, +Options</VAR>)</A></DT>
<DD class="defbody">
Parse <VAR>Source</VAR> and return the resulting structure in
<VAR>ListOfContent</VAR>. <VAR>Source</VAR> is either a term of the 
format
<CODE>stream(StreamHandle)</CODE> or a file-name. <VAR>Options</VAR> is 
a list of options controlling the conversion process.

<P>A proper XML document contains only a single toplevel element whose 
name matches the document type. Nevertheless, a list is returned for 
consistency with the representation of element content. The
<VAR>ListOfContent</VAR> consists of the following types:

<DL class="latex">
<DT><STRONG><VAR>Atom</VAR></STRONG></DT>
<DD class="defbody">
Atoms are used to represent <CODE>CDATA</CODE>. Note this is possible in 
SWI-Prolog, as there is no length-limit on atoms and atom garbage 
collection is provided.</DD>
<DT><STRONG>element</STRONG>(<VAR>Name, ListAttributes, ListOfContent</VAR>)</DT>
<DD class="defbody">
<VAR>Name</VAR> is the name of the element. Using SGML, which is 
case-insensitive, all element names are returned as lowercase atoms.

<P><VAR>ListOfAttributes</VAR> is a list of <VAR>Name</VAR>=<VAR>Value</VAR> 
pairs for attributes. Attributes of type <CODE>CDATA</CODE> are returned 
literal. Multi-valued attributes (<CODE>NAMES</CODE>, <EM>etc.</EM>) are 
returned as a list of atoms. Handling attributes of the types <CODE>NUMBER</CODE> 
and <CODE>NUMBERS</CODE> depends on the setting of the <CODE>number(+NumberMode)</CODE> 
attribute through
<A NAME="idx:setsgmlparser2:9"></A><A class="pred" href="#set_sgml_parser/2">set_sgml_parser/2</A> 
or <A NAME="idx:loadstructure3:10"></A><A class="pred" href="#load_structure/3">load_structure/3</A>. 
By default they are returned as atoms, but automatic conversion to 
Prolog integers is supported. <VAR>ListOfContent</VAR> defines the 
content for the element.</DD>
<DT><STRONG>sdata</STRONG>(<VAR>Text</VAR>)</DT>
<DD class="defbody">
If an entity with declared content-type <CODE>SDATA</CODE> is 
encountered, this term is returned holding the data in <VAR>Text</VAR>.</DD>
<DT><STRONG>ndata</STRONG>(<VAR>Text</VAR>)</DT>
<DD class="defbody">
If an entity with declared content-type <CODE>NDATA</CODE> is 
encountered, this term is returned holding the data in <VAR>Text</VAR>.
</DD>
<DT><STRONG>pi</STRONG>(<VAR>Text</VAR>)</DT>
<DD class="defbody">
If a processing instruction is encountered (<CODE>&lt;?...?&gt;</CODE>), <VAR>Text</VAR> 
holds the text of the processing instruction. Please note that the
<CODE>&lt;?xml ...?&gt;</CODE> instruction is handled internally.
</DD>
</DL>

<P>The <VAR>Options</VAR> list controls the conversion process. 
Currently defined options are:

<DL class="latex">
<DT><STRONG>dtd</STRONG>(<VAR>?DTD</VAR>)</DT>
<DD class="defbody">
Reference to a DTD object. If specified, the <CODE>&lt;!DOCTYPE ...&gt;</CODE> 
declaration is ignored and the document is parsed and validated against 
the provided DTD. If provided as a variable, the created DTD is 
returned. See <A class="sec" href="#sec:3.5">section 3.5</A>.</DD>
<DT><STRONG>dialect</STRONG>(<VAR>+Dialect</VAR>)</DT>
<DD class="defbody">
Specify the parsing dialect. Supported are <CODE>sgml</CODE> (default), <CODE>xml</CODE> 
and <CODE>xmlns</CODE>. See <A class="sec" href="#sec:3.3">section 3.3</A> 
for details on the differences.</DD>
<DT><STRONG>shorttag</STRONG>(<VAR>+Bool</VAR>)</DT>
<DD class="defbody">
Define whether SHORTTAG abbreviation is accepted. The default is true 
for SGML mode and false for the XML modes. Without SHORTTAG, a
<CODE>/</CODE> is accepted with warning as part of an unquoted 
attribute-value, though <CODE>/&gt;</CODE> still closes the element-tag 
in XML mode. It may be set to false for parsing HTML documents to allow 
for unquoted URLs containing <CODE>/</CODE>.</DD>
<DT><STRONG>space</STRONG>(<VAR>+SpaceMode</VAR>)</DT>
<DD class="defbody">
Sets the `space-handling-mode' for the initial environment. This mode is 
inherited by the other environments, which can override the inherited 
value using the XML reserved attribute <CODE>xml:space</CODE>. See
<A class="sec" href="#sec:3.2">section 3.2</A>.</DD>
<DT><STRONG>number</STRONG>(<VAR>+NumberMode</VAR>)</DT>
<DD class="defbody">
Determines how attributes of type <CODE>NUMBER</CODE> and <CODE>NUMBERS</CODE> 
are handled. If <CODE>token</CODE> (default) they are passed as an atom. 
If
<CODE>integer</CODE> the parser attempts to convert the value to an 
integer. If successful, the attribute is passed as a Prolog integer. 
Otherwise it is still passed as an atom. Note that SGML defines a 
numeric attribute to be a sequence of digits. The <CODE>-</CODE> sign is 
not allowed and
<CODE>1</CODE> is different from <CODE>01</CODE>. For this reason the 
default is to handle numeric attributes as tokens. If conversion to 
integer is enabled, negative values are silently accepted.</DD>
<DT><STRONG>defaults</STRONG>(<VAR>+Bool</VAR>)</DT>
<DD class="defbody">
Determines how default and fixed values from the DTD are used. By 
default, defaults are included in the output if they do not appear in 
the source. If <CODE>false</CODE>, only the attributes occurring in the 
source are emitted.</DD>
<DT><STRONG>entity</STRONG>(<VAR>+Name, +Value</VAR>)</DT>
<DD class="defbody">
Defines (overwrites) an entity definition. At the moment, only
<CODE>CDATA</CODE> entities can be specified with this construct. 
Multiple entity options are allowed.</DD>
<DT><STRONG>file</STRONG>(<VAR>+Name</VAR>)</DT>
<DD class="defbody">
Sets the name of the file on which errors are reported. Sets the 
linenumber to 1.</DD>
<DT><STRONG>line</STRONG>(<VAR>+Line</VAR>)</DT>
<DD class="defbody">
Sets the starting line-number for reporting errors.</DD>
<DT><STRONG>max_errors</STRONG>(<VAR>+Max</VAR>)</DT>
<DD class="defbody">
Sets the maximum number of errors. If this number is reached, an 
exception of the format below is raised. The default is 50. Using
<CODE>max_errors(-1)</CODE> makes the parser continue, no matter how 
many errors it encounters.
<BLOCKQUOTE>
<CODE>error(limit_exceeded(max_errors, Max), _)</CODE>
</BLOCKQUOTE>
</DD>
</DL>

</DD>
</DL>

<H3><A NAME="sec:3.2"><SPAN class="sec-nr">3.2</SPAN> <SPAN class="sec-title">Handling 
white-space</SPAN></A></H3>

<A NAME="sec:space"></A>

<P>SGML2PL has four modes for handling white-space. The initial mode can 
be switched using the <CODE>space(SpaceMode)</CODE> option to
<A NAME="idx:loadstructure3:11"></A><A class="pred" href="#load_structure/3">load_structure/3</A> 
and <A NAME="idx:setsgmlparser2:12"></A><A class="pred" href="#set_sgml_parser/2">set_sgml_parser/2</A>. 
In XML mode, the mode is further controlled by the <CODE>xml:space</CODE> 
attribute, which may be specified both in the DTD and in the document. 
The defined modes are:

<DL class="latex">
<DT><STRONG>space</STRONG>(<VAR>sgml</VAR>)</DT>
<DD class="defbody">
In SGML, newlines at the start and end of an element are removed.<SUP class="fn">2<SPAN class="fn-text">In 
addition, newlines at the end of lines containing only markup should be 
deleted. This is not yet implemented.</SPAN></SUP> This is the default 
mode for the SGML dialect.</DD>
<DT><STRONG>space</STRONG>(<VAR>preserve</VAR>)</DT>
<DD class="defbody">
White space is passed literally to the application. This mode leaves all 
white space handling to the application. This is the default mode for 
the XML dialect.</DD>
<DT><STRONG>space</STRONG>(<VAR>default</VAR>)</DT>
<DD class="defbody">
In addition to <CODE>sgml</CODE> space-mode, all consequtive white-space 
is reduced to a single space-character. This mode canonises all white 
space.</DD>
<DT><STRONG>space</STRONG>(<VAR>remove</VAR>)</DT>
<DD class="defbody">
In addition to <CODE>default</CODE>, all leading and trailing 
white-space is removed from <CODE>CDATA</CODE> objects. If, as a result, 
the <CODE>CDATA</CODE> becomes empty, nothing is passed to the 
application. This mode is especially handy for processing 
`data-oriented' documents, such as RDF. It is not suitable for normal 
text documents. Consider the HTML fragment below. When processed in this 
mode, the spaces between the three modified words are lost. This mode is 
not part of any standard; XML 1.0 allows only <CODE>default</CODE> and <CODE>preserve</CODE>.

<PRE class="code">
Consider adjacent &lt;b&gt;bold&lt;/b&gt; &lt;ul&gt;and&lt;/ul&gt; &lt;it&gt;italic&lt;/it&gt; words.
</PRE>

<P></DD>
</DL>

<H3><A NAME="sec:3.3"><SPAN class="sec-nr">3.3</SPAN> <SPAN class="sec-title">XML 
documents</SPAN></A></H3>

<A NAME="sec:xml"></A>

<P>The parser can operate in two modes: <CODE>sgml</CODE> mode and <CODE>xml</CODE> 
mode, as defined by the <CODE>dialect(Dialect)</CODE> option. Regardless 
of this option, if the first line of the document reads as below, the 
parser is switched automatically into XML mode.

<PRE class="code">
&lt;?xml ... ?&gt;
</PRE>

<P>Currently switching to XML mode implies:

<P>
<UL class="latex">
<LI><I>XML empty elements</I><BR>
The construct <CODE>&lt;element [attribute...] /&gt;</CODE> is 
recognised as an empty element.

<P>
<LI><I>Predefined entities</I><BR>
The following entitities are predefined: <CODE>lt</CODE> (<CODE>&lt;</CODE>), <CODE>gt</CODE> 
(<CODE>&gt;</CODE>), <CODE>amp</CODE> (<CODE>&amp;</CODE>), <CODE>apos</CODE> 
(<CODE>'</CODE>) and <CODE>quot</CODE> (<CODE>"</CODE>).

<P>
<LI><I>Case sensitivity</I><BR>
In XML mode, names are treated case-sensitive, except for the DTD 
reserved names (i.e. <CODE>ELEMENT</CODE>, <EM>etc.</EM>).

<P>
<LI><I>Character classes</I><BR>
In XML mode, underscores (<CODE>_</CODE>) and colon (<CODE>:</CODE>) are 
allowed in names.

<P>
<LI><I>White-space handling</I><BR>
White space mode is set to <CODE>preserve</CODE>. In addition to setting 
white-space handling at the toplevel the XML reserved attribute
<CODE>xml:space</CODE> is honoured. It may appear both in the document 
and the DTD. The <CODE>remove</CODE> extension is honoured as
<CODE>xml:space</CODE> value. For example, the DTD statement below 
ensures that the <CODE>pre</CODE> element preserves space, regardless of 
the default processing mode.

<PRE class="code">
&lt;!ATTLIST pre xml:space nmtoken #fixed preserve&gt;
</PRE>

<P>
</UL>

<H4><A NAME="sec:3.3.1"><SPAN class="sec-nr">3.3.1</SPAN> <SPAN class="sec-title">XML 
Namespaces</SPAN></A></H4>

<A NAME="sec:xmlns"></A>

<P>Using the <EM>dialect</EM> <CODE>xmlns</CODE>, the parser will 
interpret XML namespaces. In this case, the names of elements are 
returned as a term of the format
<BLOCKQUOTE>
<VAR>URL</VAR><CODE>:</CODE><VAR>LocalName</VAR>
</BLOCKQUOTE>

<P>If an identifier has no namespace and there is no default namespace 
it is returned as a simple atom. If an identifier has a namespace but 
this namespace is undeclared, the namespace name rather than the related 
URL is returned.

<P>Attributes declaring namespaces (<TT>xmlns:&lt;<VAR>ns</VAR>&gt;=&lt;<VAR>url</VAR>&gt;</TT>) 
are reported as if <CODE>xmlns</CODE> were not a defined resource.

<P>In many cases, getting attribute-names as <VAR>url</VAR>:<VAR>name</VAR> 
is not desirable. Such terms are hard to unify and sometimes multiple 
URLs may be mapped to the same identifier. This may happen due to poor 
version management, poor standardisation or because the the application 
doesn't care too much about versions. This package defines two 
call-backs that can be set using <A NAME="idx:setsgmlparser2:13"></A><A class="pred" href="#set_sgml_parser/2">set_sgml_parser/2</A> 
to deal with this problem.

<P>The call-back <CODE>xmlns</CODE> is called as XML namespaces are 
noticed. It can be used to extend a canonical mapping for later use by 
the <CODE>urlns</CODE> call-back. The following illustrates this 
behaviour. Any namespace containing <CODE>rdf-syntax</CODE> in its URL 
or that is used as
<CODE>rdf</CODE> namespace is canonised to <CODE>rdf</CODE>. This 
implies that any attribute and element name from the RDF namespace 
appears as
<CODE>rdf:\bnfmeta{name}</CODE>

<PRE class="code">
:- dynamic
        xmlns/3.

on_xmlns(rdf, URL, _Parser) :- !,
        asserta(xmlns(URL, rdf, _)).
on_xmlns(_, URL, _Parser) :-
        sub_atom(URL, _, _, _, 'rdf-syntax'), !,
        asserta(xmlns(URL, rdf, _)).

load_rdf_xml(File, Term) :-
        load_structure(File, Term,
                       [ dialect(xmlns),
                         call(xmlns, on_xmlns),
                         call(urlns, xmlns)
                       ]).
</PRE>

<P>The library provides <A NAME="idx:irixmlnamespace3:14"></A><A class="pred" href="#iri_xml_namespace/3">iri_xml_namespace/3</A> 
to break down an IRI into its namespace and localname:

<DL class="latex">
<DT class="pubdef"><span class="pred-tag">[det]</span><A NAME="iri_xml_namespace/3"><STRONG>iri_xml_namespace</STRONG>(<VAR>+IRI, 
-Namespace, -Localname</VAR>)</A></DT>
<DD class="defbody">
Split an IRI (Unicode URI) into its <VAR>Namespace</VAR> (an IRI) and
<VAR>Localname</VAR> (a Unicode XML name, see <A NAME="idx:xmlname2:15"></A><A class="pred" href="#xml_name/2">xml_name/2</A>). 
The
<VAR>Localname</VAR> is defined as the longest last part of the IRI that 
satisfies the syntax of an XML name. With IRI schemas that are designed 
to work with XML namespaces, this will typically break the IRI on the 
last <CODE>#</CODE> or <CODE>/</CODE>. Note however that this can 
produce unexpected results. E.g., in the example below, one might expect 
the namespace to be <A class="url" href="http://example.com/images\#">http://example.com/images\#</A>, 
but an XML name cannot start with a digit.

<PRE class="code">
?- iri_xml_namespace('http://example.com/images#12345', NS, L).
NS = 'http://example.com/images#12345',
L = ''.
</PRE>

<P>As we see from the example above, the <VAR>Localname</VAR> can be the 
empty atom. Similarly, <VAR>Namespace</VAR> can be the empty atom if <VAR>IRI</VAR> 
is an XML name. Applications will often have to check for either or both 
these conditions. We decided against failing in these conditions because 
the application typically wants to know which of the two conditions 
(empty namespace or empty localname) holds. This predicate is often used 
for generating RDF/XML from an RDF graph.</DD>
<DT class="pubdef"><span class="pred-tag">[det]</span><A NAME="iri_xml_namespace/2"><STRONG>iri_xml_namespace</STRONG>(<VAR>+IRI, 
-Namespace</VAR>)</A></DT>
<DD class="defbody">
Same as <A NAME="idx:irixmlnamespace3:16"></A><A class="pred" href="#iri_xml_namespace/3">iri_xml_namespace/3</A>, 
but avoids creating an atom for the
<VAR>Localname</VAR>.
</DD>
</DL>

<H3><A NAME="sec:3.4"><SPAN class="sec-nr">3.4</SPAN> <SPAN class="sec-title">DTD-Handling</SPAN></A></H3>

<P>The DTD (<B>D</B>ocument <B>T</B>ype <B>D</B>efinition) is a separate 
entity in sgml2pl, that can be created, freed, defined and inspected. 
Like the parser itself, it is filled by opening it as a Prolog output 
stream and sending data to it. This section summarises the predicates 
for handling the DTD.

<DL class="latex">
<DT class="pubdef"><A NAME="new_dtd/2"><STRONG>new_dtd</STRONG>(<VAR>+DocType, 
-DTD</VAR>)</A></DT>
<DD class="defbody">
Creates an empty DTD for the named <VAR>DocType</VAR>. The returned 
DTD-reference is an opaque term that can be used in the other predicates 
of this package.</DD>
<DT class="pubdef"><A NAME="free_dtd/1"><STRONG>free_dtd</STRONG>(<VAR>+DTD</VAR>)</A></DT>
<DD class="defbody">
Deallocate all resources associated to the DTD. Further use of <VAR>DTD</VAR> 
is invalid.</DD>
<DT class="pubdef"><A NAME="load_dtd/2"><STRONG>load_dtd</STRONG>(<VAR>+DTD, 
+File</VAR>)</A></DT>
<DD class="defbody">
Define the DTD by loading the SGML-DTD file <VAR>File</VAR>. Same as <A NAME="idx:loaddtd3:17"></A><A class="pred" href="#load_dtd/3">load_dtd/3</A> 
with empty option list.</DD>
<DT class="pubdef"><A NAME="load_dtd/3"><STRONG>load_dtd</STRONG>(<VAR>+DTD, 
+File, +Options</VAR>)</A></DT>
<DD class="defbody">
Define the DTD by loading <VAR>File</VAR>. Defined options are the
<CODE>dialect</CODE> option from <A NAME="idx:opendtd3:18"></A><A class="pred" href="#open_dtd/3">open_dtd/3</A> 
and the <CODE>encoding</CODE> option from <A NAME="idx:open4:19"></A><SPAN class="pred-ext">open/4</SPAN>. 
Notably the <CODE>dialect</CODE> option must match the dialect used for 
subsequent parsing using this DTD.</DD>
<DT class="pubdef"><A NAME="open_dtd/3"><STRONG>open_dtd</STRONG>(<VAR>+DTD, 
+Options, -OutStream</VAR>)</A></DT>
<DD class="defbody">
Open a DTD as an output stream. See <A NAME="idx:loaddtd2:20"></A><A class="pred" href="#load_dtd/2">load_dtd/2</A> 
for an example. Defined options are:

<DL class="latex">
<DT><STRONG>dialect</STRONG>(<VAR>Dialect</VAR>)</DT>
<DD class="defbody">
Define the DTD dialect. Default is <CODE>sgml</CODE>. Using <CODE>xml</CODE> 
or
<CODE>xmlns</CODE> processes the DTD case-sensitive.
</DD>
</DL>

</DD>
<DT class="pubdef"><A NAME="dtd/2"><STRONG>dtd</STRONG>(<VAR>+DocType, 
-DTD</VAR>)</A></DT>
<DD class="defbody">
Find the DTD representing the indicated <EM>doctype</EM>. This predicate 
uses a cache of DTD objects. If a doctype has no associated dtd, it 
searches for a file using the file search path <CODE>dtd</CODE> using 
the call:

<PRE class="code">
...,
absolute_file_name(dtd(Type),
                   [ extensions([dtd]),
                     access(read)
                   ], DtdFile),
...
</PRE>

<P>Note that DTD objects may be modified while processing errornous 
documents. For example, loading an SGML document starting with
<CODE>&lt;?xml ...?&gt;</CODE> switches the DTD to XML mode and 
encountering unknown elements adds these elements to the DTD object. 
Re-using a DTD object to parse multiple documents should be restricted 
to situations where the documents processed are known to be error-free.</DD>
<DT class="pubdef"><A NAME="dtd_property/2"><STRONG>dtd_property</STRONG>(<VAR>+DTD, 
?Property</VAR>)</A></DT>
<DD class="defbody">
This predicate is used to examine the content of a DTD. Property is one 
of:

<DL class="latex">
<DT><STRONG>doctype</STRONG>(<VAR>DocType</VAR>)</DT>
<DD class="defbody">
An atom representing the document-type defined by this DTD.</DD>
<DT><STRONG>elements</STRONG>(<VAR>ListOfElements</VAR>)</DT>
<DD class="defbody">
A list of atoms representing the names of the elements in this DTD.</DD>
<DT><STRONG>element</STRONG>(<VAR>Name, Omit, Content</VAR>)</DT>
<DD class="defbody">
The DTD contains an element with the given name. <VAR>Omit</VAR> is a 
term of the format <CODE>omit(OmitOpen, OmitClose)</CODE>, where both 
arguments are booleans (<CODE>true</CODE> or <CODE>false</CODE> 
representing whether the open- or close-tag may be omitted. <VAR>Content</VAR> 
is the content-model of the element represented as a Prolog term. This 
term takes the following form:

<DL class="latex">
<DT><STRONG>empty</STRONG></DT>
<DD class="defbody">
The element has no content.</DD>
<DT><STRONG>cdata</STRONG></DT>
<DD class="defbody">
The element contains non-parsed character data. All data up to the 
matching end-tag is included in the data (<EM>declared content</EM>).</DD>
<DT><STRONG>rcdata</STRONG></DT>
<DD class="defbody">
As <CODE>cdata</CODE>, but entity-references are expanded.</DD>
<DT><STRONG>any</STRONG></DT>
<DD class="defbody">
The element may contain any number of any element from the DTD in any 
order.</DD>
<DT><STRONG>#pcdata</STRONG></DT>
<DD class="defbody">
The element contains parsed character data .</DD>
<DT><STRONG><VAR>element</VAR></STRONG>(<VAR><VAR>element</VAR></VAR>)</DT>
<DD class="defbody">
n element with this name.</DD>
<DT><STRONG>*</STRONG>(<VAR>SubModel</VAR>)</DT>
<DD class="defbody">
0 or more appearances.</DD>
<DT><STRONG>?</STRONG>(<VAR>SubModel</VAR>)</DT>
<DD class="defbody">
0 or one appearance.</DD>
<DT><STRONG>+</STRONG>(<VAR>SubModel</VAR>)</DT>
<DD class="defbody">
1 or more appearances.</DD>
<DT><STRONG>,</STRONG>(<VAR>SubModel1, SubModel2</VAR>)</DT>
<DD class="defbody">
<VAR>SubModel1</VAR> followed by <VAR>SubModel2</VAR>.</DD>
<DT><STRONG>&amp;</STRONG>(<VAR>SubModel1, SubModel2</VAR>)</DT>
<DD class="defbody">
<VAR>SubModel1</VAR> and <VAR>SubModel2</VAR> in any order.</DD>
<DT><STRONG><CODE>|</CODE></STRONG>(<VAR>SubModel1, SubModel2</VAR>)</DT>
<DD class="defbody">
<VAR>SubModel1</VAR> or <VAR>SubModel2</VAR>.
</DD>
</DL>

</DD>
<DT><STRONG>attributes</STRONG>(<VAR>Element, ListOfAttributes</VAR>)</DT>
<DD class="defbody">
<VAR>ListOfAttributes</VAR> is a list of atoms representing the 
attributes of the element <VAR>Element</VAR>.</DD>
<DT><STRONG>attribute</STRONG>(<VAR>Element, Attribute, Type, Default</VAR>)</DT>
<DD class="defbody">
Query an element. <VAR>Type</VAR> is one of <CODE>cdata</CODE>, <CODE>entity</CODE>,
<CODE>id</CODE>, <CODE>idref</CODE>, <CODE>name</CODE>, <CODE>nmtoken</CODE>,
<CODE>notation</CODE>, <CODE>number</CODE> or <CODE>nutoken</CODE>. For 
DTD types that allow for a list, the notation <CODE>list(Type)</CODE> is 
used. Finally, the DTD construct <CODE>(a|b|...)</CODE> is mapped to the 
term
<CODE>nameof(ListOfValues)</CODE>.

<P><VAR>Default</VAR> describes the sgml default. It is one <CODE>required</CODE>,
<CODE>current</CODE>, <CODE>conref</CODE> or <CODE>implied</CODE>. If a 
real default is present, it is one of <CODE>default(Value)</CODE> or <CODE>fixed(Value)</CODE>.</DD>
<DT><STRONG>entities</STRONG>(<VAR>ListOfEntities</VAR>)</DT>
<DD class="defbody">
<VAR>ListOfEntities</VAR> is a list of atoms representing the names of 
the defined entities.</DD>
<DT><STRONG>entity</STRONG>(<VAR>Name, Value</VAR>)</DT>
<DD class="defbody">
<VAR>Name</VAR> is the name of an entity with given value. Value is one 
of

<DL class="latex">
<DT><STRONG><VAR>Atom</VAR></STRONG></DT>
<DD class="defbody">
If the value is atomic, it represents the literal value of the entity.</DD>
<DT><STRONG>system</STRONG>(<VAR>Url</VAR>)</DT>
<DD class="defbody">
<VAR>Url</VAR> is the URL of the system external entity.</DD>
<DT><STRONG>public</STRONG>(<VAR>Id, Url</VAR>)</DT>
<DD class="defbody">
For external public entities, <VAR>Id</VAR> is the identifier. If an URL 
is provided this is returned in <VAR>Url</VAR>. Otherwise this argument 
is unbound.
</DD>
</DL>

</DD>
<DT><STRONG>notations</STRONG>(<VAR>ListOfNotations</VAR>)</DT>
<DD class="defbody">
Returns a list holding the names of all <CODE>NOTATION</CODE> 
declarations.</DD>
<DT><STRONG>notation</STRONG>(<VAR>Name, Decl</VAR>)</DT>
<DD class="defbody">
Unify <VAR>Decl</VAR> with a list if <CODE>system(+File)</CODE> and/or
<CODE>public(+PublicId)</CODE>.
</DD>
</DL>

</DD>
</DL>

<H4><A NAME="sec:3.4.1"><SPAN class="sec-nr">3.4.1</SPAN> <SPAN class="sec-title">The 
DOCTYPE declaration</SPAN></A></H4>

<P>As this parser allows for processing partial documents and process 
the DTD separately, the DOCTYPE declaration plays a special role.

<P>If a document has no DOCTYPE declaraction, the parser returns a list 
holding all elements and CDATA found. If the document has a DOCTYPE 
declaraction, the parser will open the element defined in the DOCTYPE as 
soon as the first real data is encountered.

<H3><A NAME="sec:3.5"><SPAN class="sec-nr">3.5</SPAN> <SPAN class="sec-title">Extracting 
a DTD</SPAN></A></H3>

<A NAME="sec:implicitdtd"></A>

<P>Some documents have no DTD. One of the neat facilities of this 
library is that it builds a DTD while parsing a document with an
<EM>implicit</EM> DTD. The resulting DTD contains all elements 
encountered in the document. For each element the content model is a 
disjunction of elements and possibly <CODE>#PCDATA</CODE> that can be 
repeated. Thus, if we found element <CODE>y</CODE> and CDATA in element
<CODE>x</CODE>, the model is:

<PRE class="code">
&lt;!ELEMENT x - - (y|#PCDATA)*&gt;
</PRE>

<P>Any encountered attribute is added to the attribute list with the 
type
<CODE>CDATA</CODE> and default <CODE>#IMPLIED</CODE>.

<P>The example below extracts the elements used in an unknown XML 
document.

<PRE class="code">
elements_in_xml_document(File, Elements) :-
        load_structure(File, _,
                       [ dialect(xml),
                         dtd(DTD)
                       ]),
        dtd_property(DTD, elements(Elements)),
        free_dtd(DTD).
</PRE>

<H3><A NAME="sec:3.6"><SPAN class="sec-nr">3.6</SPAN> <SPAN class="sec-title">Parsing 
Primitives</SPAN></A></H3>

<DL class="latex">
<DT class="pubdef"><A NAME="new_sgml_parser/2"><STRONG>new_sgml_parser</STRONG>(<VAR>-Parser, 
+Options</VAR>)</A></DT>
<DD class="defbody">
Creates a new parser. A parser can be used one or multiple times for 
parsing documents or parts thereof. It may be bound to a DTD or the DTD 
may be left implicit, in which case it is created from the document 
prologue or parsing is performed without a DTD. Options:

<DL class="latex">
<DT><STRONG>dtd</STRONG>(<VAR>?DTD</VAR>)</DT>
<DD class="defbody">
If specified with an initialised DTD, this DTD is used for parsing the 
document, regardless of the document prologue. If specified using as a 
variable, a reference to the created DTD is returned. This DTD may be 
created from the document prologue or build implicitely from the 
document's content.
</DD>
</DL>

</DD>
<DT class="pubdef"><A NAME="free_sgml_parser/1"><STRONG>free_sgml_parser</STRONG>(<VAR>+Parser</VAR>)</A></DT>
<DD class="defbody">
Destroy all resources related to the parser. This does not destroy the 
DTD if the parser was created using the <CODE>dtd(DTD)</CODE> option.</DD>
<DT class="pubdef"><A NAME="set_sgml_parser/2"><STRONG>set_sgml_parser</STRONG>(<VAR>+Parser, 
+Option</VAR>)</A></DT>
<DD class="defbody">
Sets attributes to the parser. Currently defined attributes:

<DL class="latex">
<DT><STRONG>file</STRONG>(<VAR>File</VAR>)</DT>
<DD class="defbody">
Sets the file for reporting errors and warnings. Sets the line to 1.
</DD>
<DT><STRONG>line</STRONG>(<VAR>Line</VAR>)</DT>
<DD class="defbody">
Sets the current line. Useful if the stream is not at the start of the 
(file) object for generating proper line-numbers.
</DD>
<DT><STRONG>charpos</STRONG>(<VAR>Offset</VAR>)</DT>
<DD class="defbody">
Sets the current character location. See also the <CODE>file(File)</CODE> 
option.
</DD>
<DT><STRONG>dialect</STRONG>(<VAR>Dialect</VAR>)</DT>
<DD class="defbody">
Set the markup dialect. Known dialects:

<DL class="latex">
<DT><STRONG>sgml</STRONG></DT>
<DD class="defbody">
The default dialect is to process as SGML. This implies markup is 
case-insensitive and standard SGML abbreviation is allowed (abreviated 
attributes and omitted tags).</DD>
<DT><STRONG>xml</STRONG></DT>
<DD class="defbody">
This dialect is selected automatically if the processing instruction
<CODE>&lt;?xml ...&gt;</CODE> is encountered. See <A class="sec" href="#sec:3.3">section 
3.3</A> for details.</DD>
<DT><STRONG>xmlns</STRONG></DT>
<DD class="defbody">
Process file as XML file with namespace support. See <A class="sec" href="#sec:3.3.1">section 
3.3.1</A> for details. See also the <CODE>qualify_attributes</CODE> 
option below.
</DD>
</DL>

</DD>
<DT><STRONG>xmlns</STRONG>(<VAR>+URI</VAR>)</DT>
<DD class="defbody">
Set the default namespace of the outer environment. This option is 
provided to process partial XML content with proper namespace 
resolution.</DD>
<DT><STRONG>xmlns</STRONG>(<VAR>+NS, +URI</VAR>)</DT>
<DD class="defbody">
Specify a namespace for the outer environment. This option is provided 
to process partial XML content with proper namespace resolution.</DD>
<DT><STRONG>qualify_attributes</STRONG>(<VAR>Boolean</VAR>)</DT>
<DD class="defbody">
How to handle unqualified attribute (i.e. without an explicit namespace) 
in XML namespace (<CODE>xmlns</CODE>) mode. Default and standard 
compliant is not to qualify such elements. If <CODE>true</CODE>, such 
attributes are qualified with the namespace of the element they appear 
in. This option is for backward compatibility as this is the behaviour 
of older versions. In addition, the namespace document suggests 
unqualified attributes are often interpreted in the namespace of their 
element.</DD>
<DT><STRONG>space</STRONG>(<VAR>SpaceMode</VAR>)</DT>
<DD class="defbody">
Define the initial handling of white-space in PCDATA. This attribute is 
described in <A class="sec" href="#sec:3.2">section 3.2</A>.</DD>
<DT><STRONG>number</STRONG>(<VAR>NumberMode</VAR>)</DT>
<DD class="defbody">
If <CODE>token</CODE> (default), attributes of type number are passed as 
a Prolog atom. If <CODE>integer</CODE>, such attributes are translated 
into Prolog integers. If the conversion fails (e.g. due to overflow) a 
warning is issued and the value is passed as an atom.</DD>
<DT><STRONG>encoding</STRONG>(<VAR>Encoding</VAR>)</DT>
<DD class="defbody">
Set the initial encoding. The default initial encoding for XML documents 
is UTF-8 and for SGML documents ISO-8859-1. XML documents may change the 
encoding using the <CODE>encoding=</CODE> attribute in the header. 
Explicit use of this option is only required to parse non-conforming 
documents. Currently accepted values are <CODE>iso-8859-1</CODE> and
<CODE>utf-8</CODE>.</DD>
<DT><STRONG>doctype</STRONG>(<VAR>Element</VAR>)</DT>
<DD class="defbody">
Defines the toplevel element expected. If a <CODE>&lt;!DOCTYPE</CODE> 
declaration has been parsed, the default is the defined doctype. The 
parser can be instructed to accept the first element encountered as the 
toplevel using <CODE>doctype(_)</CODE>. This feature is especially 
useful when parsing part of a document (see the <CODE>parse</CODE> 
option to
<A NAME="idx:sgmlparse2:21"></A><A class="pred" href="#sgml_parse/2">sgml_parse/2</A>.
</DD>
</DL>

</DD>
<DT class="pubdef"><A NAME="get_sgml_parser/2"><STRONG>get_sgml_parser</STRONG>(<VAR>+Parser, 
-Option</VAR>)</A></DT>
<DD class="defbody">
Retrieve infomation on the current status of the parser. Notably useful 
if the parser is used in the call-back mode. Currently defined options:

<DL class="latex">
<DT><STRONG>file</STRONG>(<VAR>-File</VAR>)</DT>
<DD class="defbody">
Current file-name. Note that this may be different from the provided 
file if an external entity is being loaded.</DD>
<DT><STRONG>line</STRONG>(<VAR>-Line</VAR>)</DT>
<DD class="defbody">
Line-offset from where the parser started its processing in the 
file-object.</DD>
<DT><STRONG>charpos</STRONG>(<VAR>-CharPos</VAR>)</DT>
<DD class="defbody">
Offset from where the parser started its processing in the file-object. 
See <A class="sec" href="#sec:6">section 6</A>.</DD>
<DT><STRONG>charpos</STRONG>(<VAR>-Start, -End</VAR>)</DT>
<DD class="defbody">
Character offsets of the start and end of the source processed causing 
the current call-back. Used in <B>PceEmacs</B> to for colouring text in 
SGML and XML modes.</DD>
<DT><STRONG>source</STRONG>(<VAR>-Stream</VAR>)</DT>
<DD class="defbody">
Prolog stream being processed. May be used in the <CODE>on_begin</CODE>, <EM>etc.</EM> 
callbacks from <A NAME="idx:sgmlparse2:22"></A><A class="pred" href="#sgml_parse/2">sgml_parse/2</A>.</DD>
<DT><STRONG>dialect</STRONG>(<VAR>-Dialect</VAR>)</DT>
<DD class="defbody">
Return the current dialect used by the parser (<CODE>sgml</CODE>, <CODE>xml</CODE> 
or <CODE>xmlns</CODE>).</DD>
<DT><STRONG>event_class</STRONG>(<VAR>-Class</VAR>)</DT>
<DD class="defbody">
The <EM>event class</EM> can be requested in call-back events. It 
denotes the cause of the event, providing useful information for syntax 
highlighting. Defined values are:

<DL class="latex">
<DT><STRONG>explicit</STRONG></DT>
<DD class="defbody">
The code generating this event is explicitely present in the document.</DD>
<DT><STRONG>omitted</STRONG></DT>
<DD class="defbody">
The current event is caused by the insertion of an omitted tag. This may 
be a normal event in SGML mode or an error in XML mode.</DD>
<DT><STRONG>shorttag</STRONG></DT>
<DD class="defbody">
The current event (<CODE>begin</CODE> or <CODE>end</CODE>) is caused by 
an element written down using the <EM>shorttag</EM> notation (<CODE>&lt;tag/value/&gt;</CODE>.</DD>
<DT><STRONG>shortref</STRONG></DT>
<DD class="defbody">
The current event is caused by the expansion of a
<EM>shortref</EM>. This allows for highlighting shortref strings in the 
source-text.
</DD>
</DL>

</DD>
<DT><STRONG>doctype</STRONG>(<VAR>-Element</VAR>)</DT>
<DD class="defbody">
Return the defined document-type (= toplevel element). See also
<A NAME="idx:setsgmlparser2:23"></A><A class="pred" href="#set_sgml_parser/2">set_sgml_parser/2</A>.</DD>
<DT><STRONG>dtd</STRONG>(<VAR>-DTD</VAR>)</DT>
<DD class="defbody">
Return the currently used DTD. See <A NAME="idx:dtdproperty2:24"></A><A class="pred" href="#dtd_property/2">dtd_property/2</A> 
for obtaining information on the DTD such as element and attribute 
properties.</DD>
<DT><STRONG>context</STRONG>(<VAR>-StackOfElements</VAR>)</DT>
<DD class="defbody">
Returns the stack of currently open elements as a list. The head of this 
list is the current element. This can be used to determine the context 
of, for example, CDATA events in call-back mode. The elements are passed 
as atoms. Currently no access to the attributes is provided.</DD>
<DT><STRONG>allowed</STRONG>(<VAR>-Elements</VAR>)</DT>
<DD class="defbody">
Determines which elements may be inserted at the current location. This 
information is returned as a list of element-names. If character data is 
allowed in the current location, <CODE>#pcdata</CODE> is part of
<VAR>Elements</VAR>. If no element is open, the <EM>doctype</EM> is 
returned.

<P>This option is intended to support syntax-sensitive editors. Such an 
editor should load the DTD, find an appropriate starting point and then 
feed all data between the starting point and the caret into the parser. 
Next it can use this option to determine the elements allowed at this 
point. Below is a code fragment illustrating this use given a parser 
with loaded DTD, an input stream and a start-location.

<PRE class="code">
        ...,
        seek(In, Start, bof, _),
        set_sgml_parser(Parser, charpos(Start)),
        set_sgml_parser(Parser, doctype(_)),
        Len is Caret - Start,
        sgml_parse(Parser,
                   [ source(In),
                     content_length(Len),
                     parse(input)       % do not complete document
                   ]),
        get_sgml_parser(Parser, allowed(Allowed)),
        ...
</PRE>

<P></DD>
</DL>

</DD>
<DT class="pubdef"><A NAME="sgml_parse/2"><STRONG>sgml_parse</STRONG>(<VAR>+Parser, 
+Options</VAR>)</A></DT>
<DD class="defbody">
Parse an XML file. The parser can operate in two input and two output 
modes. Output is either a structured term as described with
<A NAME="idx:loadstructure2:25"></A><SPAN class="pred-ext">load_structure/2</SPAN> 
or call-backs on predefined events. The first is especially suitable for 
manipulating not-too-large documents, while the latter provides a 
primitive means for handling very large documents.

<P>Input is a stream. A full description of the option-list is below.

<DL class="latex">
<DT><STRONG>document</STRONG>(<VAR>-Term</VAR>)</DT>
<DD class="defbody">
A variable that will be unified with a list describing the content of 
the document (see <A NAME="idx:loadstructure2:26"></A><SPAN class="pred-ext">load_structure/2</SPAN>).
</DD>
<DT><STRONG>source</STRONG>(<VAR>+Stream</VAR>)</DT>
<DD class="defbody">
An input stream that is read. This option <EM>must</EM> be given.
</DD>
<DT><STRONG>content_length</STRONG>(<VAR>+Characters</VAR>)</DT>
<DD class="defbody">
Stop parsing after <VAR>Characters</VAR>. This option is useful to parse 
input embedded in <EM>envelopes</EM>, such as the HTTP protocol.
</DD>
<DT><STRONG>parse</STRONG>(<VAR>Unit</VAR>)</DT>
<DD class="defbody">
Defines how much of the input is parsed. This option is used to parse 
only parts of a file.

<DL class="latex">
<DT><STRONG>file</STRONG></DT>
<DD class="defbody">
Default. Parse everything upto the end of the input.</DD>
<DT><STRONG>element</STRONG></DT>
<DD class="defbody">
The parser stops after reading the first element. Using
<CODE>source(Stream)</CODE>, this implies reading is stopped as soon as 
the element is complete, and another call may be issued on the same 
stream to read the next element.</DD>
<DT><STRONG>content</STRONG></DT>
<DD class="defbody">
The value <CODE>content</CODE> is like <CODE>element</CODE> but assumes 
the element has already been opened. It may be used in a call-back from
<CODE>call(<CODE>on_begin</CODE>, Pred)</CODE> to parse individual 
elements after validating their headers.</DD>
<DT><STRONG>declaration</STRONG></DT>
<DD class="defbody">
This may be used to stop the parser after reading the first declaration. 
This is especially useful to parse only the <CODE>doctype</CODE> 
declaration.</DD>
<DT><STRONG>input</STRONG></DT>
<DD class="defbody">
This option is intended to be used in conjunction with the
<CODE>allowed(Elements)</CODE> option of <A NAME="idx:getsgmlparser2:27"></A><A class="pred" href="#get_sgml_parser/2">get_sgml_parser/2</A>. 
It disables the parser's default to complete the parse-tree by closing 
all open elements.
</DD>
</DL>

</DD>
<DT><STRONG>max_errors</STRONG>(<VAR>+MaxErrors</VAR>)</DT>
<DD class="defbody">
Set the maximum number of errors. If this number is exceeded further 
writes to the stream will yield an I/O error exception. Printing of 
errors is suppressed after reaching this value. The default is 100.
</DD>
<DT><STRONG>syntax_errors</STRONG>(<VAR>+ErrorMode</VAR>)</DT>
<DD class="defbody">
Defines how syntax errors are handled.

<DL class="latex">
<DT><STRONG>quiet</STRONG></DT>
<DD class="defbody">
Suppress all messages.
</DD>
<DT><STRONG>print</STRONG></DT>
<DD class="defbody">
Default. Pass messages to <A NAME="idx:printmessage2:28"></A><SPAN class="pred-ext">print_message/2</SPAN>.
</DD>
<DT><STRONG>style</STRONG></DT>
<DD class="defbody">
Print dubious input such as attempts for redefinitions in the DTD using <A NAME="idx:printmessage2:29"></A><SPAN class="pred-ext">print_message/2</SPAN> 
with severity
<CODE>informational</CODE>.
</DD>
</DL>

</DD>
<DT><STRONG>xml_no_ns</STRONG>(<VAR>+Mode</VAR>)</DT>
<DD class="defbody">
Error handling if an XML namespace is not defined. Default generates an 
error. If <CODE>quiet</CODE>, the error is suppressed. Can be used 
together with <CODE>call(urlns, Closure)</CODE> to provide external 
expansion of namespaces. See also <A class="sec" href="#sec:3.3.1">section 
3.3.1</A>.</DD>
<DT><STRONG>call</STRONG>(<VAR>+Event, :PredicateName</VAR>)</DT>
<DD class="defbody">
Issue call-backs on the specified events. <VAR>PredicateName</VAR> is 
the name of the predicate to call on this event, possibly prefixed with 
a module identifier. If the handler throws an exception, parsing is 
stopped and <A NAME="idx:sgmlparse2:30"></A><A class="pred" href="#sgml_parse/2">sgml_parse/2</A> 
re-throws the exception. The defined events are:

<DL class="latex">
<DT><STRONG>begin</STRONG></DT>
<DD class="defbody">
An open-tag has been parsed. The named handler is called with three 
arguments: <CODE><VAR>Handler</VAR>(+Tag, +Attributes, +Parser)</CODE>.
</DD>
<DT><STRONG>end</STRONG></DT>
<DD class="defbody">
A close-tag has been parsed. The named handler is called with two 
arguments: <CODE><VAR>Handler</VAR>(+Tag, +Parser)</CODE>.</DD>
<DT><STRONG>cdata</STRONG></DT>
<DD class="defbody">
CDATA has been parsed. The named handler is called with two arguments:
<CODE>Handler(+CDATA, +Parser)</CODE>, where CDATA is an atom 
representing the data.</DD>
<DT><STRONG>pi</STRONG></DT>
<DD class="defbody">
A processing instruction has been parsed. The named handler is called 
with two arguments: <CODE><VAR>Handler</VAR>(+Text, +Parser)</CODE>, 
where
<VAR>Text</VAR> is the text of the processing instruction.</DD>
<DT><STRONG>decl</STRONG></DT>
<DD class="defbody">
A declaration (<CODE>&lt;!...&gt;</CODE>) has been read. The named 
handler is called with two arguments: <CODE><VAR>Handler</VAR>(+Text, 
+Parser)</CODE>, where <VAR>Text</VAR> is the text of the declaration 
with comments removed.

<P>This option is expecially useful for highlighting declarations and 
comments in editor support, where the location of the declaration is 
extracted using
<A NAME="idx:getsgmlparser2:31"></A><A class="pred" href="#get_sgml_parser/2">get_sgml_parser/2</A>.</DD>
<DT><STRONG>error</STRONG></DT>
<DD class="defbody">
An error has been encountered. the named handler is called with three 
arguments: <CODE><VAR>Handler</VAR>(+Severity, +Message, +Parser)</CODE>, 
where
<VAR>Severity</VAR> is one of <CODE>warning</CODE> or <CODE>error</CODE> 
and
<VAR>Message</VAR> is an atom representing the diagnostic message. The 
location of the error can be determined using <A NAME="idx:getsgmlparser2:32"></A><A class="pred" href="#get_sgml_parser/2">get_sgml_parser/2</A>

<P>If this option is present, errors and warnings are not reported using
<A NAME="idx:printmessage3:33"></A><SPAN class="pred-ext">print_message/3</SPAN></DD>
<DT><STRONG>xmlns</STRONG></DT>
<DD class="defbody">
When parsing an in <CODE>xmlns</CODE> mode, a new namespace declaraction 
is pushed on the environment. The named handler is called with three 
arguments: <CODE><VAR>Handler</VAR>(+NameSpace, +URL, +Parser)</CODE>. 
See <A class="sec" href="#sec:3.3.1">section 3.3.1</A> for details.</DD>
<DT><STRONG>urlns</STRONG></DT>
<DD class="defbody">
When parsing an in <CODE>xmlns</CODE> mode, this predicate can be used 
to map a url into either a canonical URL for this namespace or another 
internal identifier. See <A class="sec" href="#sec:3.3.1">section 3.3.1</A> 
for details.
</DD>
</DL>

</DD>
</DL>

</DD>
</DL>

<H4><A NAME="sec:3.6.1"><SPAN class="sec-nr">3.6.1</SPAN> <SPAN class="sec-title">Partial 
Parsing</SPAN></A></H4>

<P>In some cases, part of a document needs to be parsed. One option is 
to use <A NAME="idx:loadstructure2:34"></A><SPAN class="pred-ext">load_structure/2</SPAN> 
or one of its variations and extract the desired elements from the 
returned structure. This is a clean solution, especially on small and 
medium-sized documents. It however is unsuitable for parsing really big 
documents. Such documents can only be handled with the call-back output 
interface realised by the
<CODE>call(Event, Action)</CODE> option of <A NAME="idx:sgmlparse2:35"></A><A class="pred" href="#sgml_parse/2">sgml_parse/2</A>. 
Event-driven processing is not very natural in Prolog.

<P>The SGML2PL library allows for a mixed approach. Consider the case 
where we want to process all descriptions from RDF elements in a 
document. The code below calls <CODE>process_rdf_description(Element)</CODE> 
on each element that is directly inside an RDF element.

<PRE class="code">
:- dynamic
        in_rdf/0.

load_rdf(File) :-
        retractall(in_rdf),
        open(File, read, In),
        new_sgml_parser(Parser, []),
        set_sgml_parser(Parser, file(File)),
        set_sgml_parser(Parser, dialect(xml)),
        sgml_parse(Parser,
                   [ source(In),
                     call(begin, on_begin),
                     call(end, on_end)
                   ]),
        close(In).

on_end('RDF', _) :-
        retractall(in_rdf).

on_begin('RDF', _, _) :-
        assert(in_rdf).
on_begin(Tag, Attr, Parser) :-
        in_rdf, !,
        sgml_parse(Parser,
                   [ document(Content),
                     parse(content)
                   ]),
        process_rdf_description(element(Tag, Attr, Content)).
</PRE>

<H3><A NAME="sec:3.7"><SPAN class="sec-nr">3.7</SPAN> <SPAN class="sec-title">Type 
checking</SPAN></A></H3>

<DL class="latex">
<DT class="pubdef"><A NAME="xml_is_dom/1"><STRONG>xml_is_dom</STRONG>(<VAR>@Term</VAR>)</A></DT>
<DD class="defbody">
True if <VAR>Term</VAR> is an SGML/XML term as produced by one of the 
above predciates and acceptable by <A NAME="idx:xmlwrite3:36"></A><A class="pred" href="#xml_write/3">xml_write/3</A> 
and friends.
</DD>
</DL>

<H2><A NAME="sec:4"><SPAN class="sec-nr">4</SPAN> <SPAN class="sec-title">Stream 
encoding issues</SPAN></A></H2>

<A NAME="sec:encoding"></A>

<P>The parser can deal with ISO Latin-1 and UTF-8 encoded files, doing 
decoding based on the encoding argument provided to
<A NAME="idx:setsgmlparser2:37"></A><A class="pred" href="#set_sgml_parser/2">set_sgml_parser/2</A> 
or, for XML, based on the <CODE>encoding</CODE> attribute of the XML 
header. The parser reads from SWI-Prolog streams, which also provide 
encoding handling. Therefore, there are two modes for parsing. If the 
SWI-Prolog stream has encoding <CODE>octet</CODE> (which is the default 
for binary streams), the decoder of the SGML parser will be used and 
positions reported by the parser are octet offsets in the stream. In 
other cases, the Prolog stream decoder is used and offsets are character 
code counts.

<H2><A NAME="sec:5"><SPAN class="sec-nr">5</SPAN> <SPAN class="sec-title">library(xpath): 
Select nodes in an XML DOM</SPAN></A></H2>

<P><A NAME="sec:xpath"></A>

<DL>
<DT><B>See also</B><DD>
<A class="url" href="http://www.w3.org/TR/xpath">http://www.w3.org/TR/xpath</A>
</DL>

<P>The library <CODE>xpath.pl</CODE> provides predicates to select nodes 
from an XML DOM tree as produced by library(sgml) based on descriptions 
inspired by the XPATH language.

<P>The predicate <A class="pred" href="#xpath/3">xpath/3</A> selects a 
sub-structure of the DOM non-deterministically based on an xpath-like 
specification. Not all selectors of XPATH are implemented, but the 
ability to mix <A class="pred" href="#xpath/3">xpath/3</A> calls with 
arbitrary Prolog code provides a powerful tool for extracting 
information from XML parse-trees.

<DL class="latex">
<DT class="pubdef"><span class="pred-tag">[semidet]</span><A NAME="xpath_chk/3"><STRONG>xpath_chk</STRONG>(<VAR>+DOM, 
+Spec, ?Content</VAR>)</A></DT>
<DD class="defbody">
Semi-deterministic version of <A class="pred" href="#xpath/3">xpath/3</A>.</DD>
<DT class="pubdef"><span class="pred-tag">[nondet]</span><A NAME="xpath/3"><STRONG>xpath</STRONG>(<VAR>+DOM, 
+Spec, ?Content</VAR>)</A></DT>
<DD class="defbody">
Match an element in a <VAR>DOM</VAR> structure. The syntax is inspired 
by XPath, using () rather than[]to select inside an element. First we 
can construct paths using / and //:

<DL class="latex">
<DT><B><CODE><CODE>//</CODE></CODE>Term</B></DT>
<DD>
Select any node in the <VAR>DOM</VAR> matching term.
</DD>
<DT><B><CODE><CODE>/</CODE></CODE>Term</B></DT>
<DD>
Match the root against Term.
</DD>
<DT><B>Term</B></DT>
<DD>
Select the immediate children of the root matching Term.
</DD>
</DL>

<P>The Terms above are of type <I>callable</I>. The functor specifies 
the element name. The element name '*' refers to any element. The name <CODE>self</CODE> 
refers to the top-element itself and is often used for processing 
matches of an earlier <A class="pred" href="#xpath/3">xpath/3</A> query. 
A term NS:Term refers to an XML name in the namespace NS. Optional 
arguments specify additional constraints and functions. The arguments 
are processed from left to right. Defined conditional argument values 
are:

<DL class="latex">
<DT><B>Integer</B></DT>
<DD>
The N-th element with the given name
</DD>
<DT><B><CODE>last</CODE></B></DT>
<DD>
The last element with the given name.
</DD>
<DT><B><CODE>last</CODE> - IntExpr</B></DT>
<DD>
The IntExpr-th element counting from the last (0-based)
</DD>
</DL>

<P>Defined function argument values are:

<DL class="latex">
<DT><B><CODE>self</CODE></B></DT>
<DD>
Evaluate to the entire element
</DD>
<DT><B><CODE>text</CODE></B></DT>
<DD>
Evaluates to all text from the sub-tree as an atom
</DD>
<DT><B><CODE>normalize_space</CODE></B></DT>
<DD>
As <CODE>text</CODE>, but uses <SPAN class="pred-ext">normalize_space/2</SPAN> 
to normalise white-space in the output
</DD>
<DT><B><CODE>number</CODE></B></DT>
<DD>
Extract an integer or float from the value. Ignores leading and trailing 
white-space
</DD>
<DT><B><CODE>@</CODE>Attribute</B></DT>
<DD>
Evaluates to the value of the given attribute
</DD>
</DL>

<P>In addition, the argument-list can be <I>conditions</I>:

<DL class="latex">
<DT><B>Left = Right</B></DT>
<DD>
Succeeds if the left-hand unifies with the right-hand. E.g. 
normalize_space = 'euro'
</DD>
<DT><B>contains(Haystack, Needle)</B></DT>
<DD>
Succeeds if Needle is a sub-string of Haystack.
</DD>
</DL>

<P>Examples:

<P>Match each table-row in <VAR>DOM</VAR>:

<PRE class="code">
xpath(DOM, //tr, TR)
</PRE>

<P>Match the last cell of each tablerow in <VAR>DOM</VAR>. This example 
illustrates that a result can be the input of subsequent <A class="pred" href="#xpath/3">xpath/3</A> 
queries. Using multiple queries on the intermediate TR term guarantee 
that all results come from the same table-row:

<PRE class="code">
xpath(DOM, //tr, TR),
xpath(TR,  /td(last), TD)
</PRE>

<P>Match each <CODE>href</CODE> attribute in an <VAR>&lt;</VAR>a<VAR>&gt;</VAR> 
element

<PRE class="code">
xpath(DOM, //a(@href), HREF)
</PRE>

<P>Suppose we have a table containing rows where each first column is 
the name of a product with a link to details and the second is the price 
(a number). The following predicate matches the name, URL and price:

<PRE class="code">
product(DOM, Name, URL, Price) :-
    xpath(DOM, //tr, TR),
    xpath(TR, td(1), C1),
    xpath(C1, /self(normalize_space), Name),
    xpath(C1, a(@href), URL),
    xpath(TR, td(2, number), Price).
</PRE>

<P>Suppose we want to select books with genre="thriller" from a tree 
containing elements <CODE>&lt;book genre=...&gt;</CODE>

<PRE class="code">
thriller(DOM, Book) :-
    xpath(DOM, //book(@genre=thiller), Book).
</PRE>

<P></DD>
</DL>

<H2><A NAME="sec:6"><SPAN class="sec-nr">6</SPAN> <SPAN class="sec-title">Processing 
Indexed Files</SPAN></A></H2>

<A NAME="sec:indexaccess"></A>

<P>In some cases applications wish to process small portions of large 
SGML, XML or RDF files. For example, the <EM>OpenDirectory</EM> project 
by Netscape has produced a 90MB RDF file representing the main index. 
The parser described here can process this document as a unit, but 
loading takes 85 seconds on a Pentium-II 450 and the resulting term 
requires about 70MB global stack. One option is to process the entire 
document and output it as a Prolog fact-base of RDF triplets, but in 
many cases this is undesirable. Another example is a large SGML file 
containing online documentation. The application normally wishes to 
provide only small portions at a time to the user. Loading the entire 
document into memory is then undesirable.

<P>Using the <CODE>parse(element)</CODE> option, we open a file, seek 
(using <A NAME="idx:seek4:38"></A><SPAN class="pred-ext">seek/4</SPAN>) 
to the position of the element and read the desired element.

<P>The index can be built using the call-back interface of
<A NAME="idx:sgmlparse2:39"></A><A class="pred" href="#sgml_parse/2">sgml_parse/2</A>. 
For example, the following code makes an index of the <CODE>structure.rdf</CODE> 
file of the OpenDirectory project:

<PRE class="code">
:- dynamic
        location/3.                     % Id, File, Offset

rdf_index(File) :-
        retractall(location(_,_)),
        open(File, read, In, [type(binary)]),
        new_sgml_parser(Parser, []),
        set_sgml_parser(Parser, file(File)),
        set_sgml_parser(Parser, dialect(xml)),
        sgml_parse(Parser,
                   [ source(In),
                     call(begin, index_on_begin)
                   ]),
        close(In).

index_on_begin(_Element, Attributes, Parser) :-
        memberchk('r:id'=Id, Attributes),
        get_sgml_parser(Parser, charpos(Offset)),
        get_sgml_parser(Parser, file(File)),
        assert(location(Id, File, Offset)).
</PRE>

<P>The following code extracts the RDF element with required id:

<PRE class="code">
rdf_element(Id, Term) :-
        location(Id, File, Offset),
        load_structure(File, Term,
                       [ dialect(xml),
                         offset(Offset),
                         parse(element)
                       ]).
</PRE>

<H2><A NAME="sec:7"><SPAN class="sec-nr">7</SPAN> <SPAN class="sec-title">External 
entities</SPAN></A></H2>

<P>While processing an SGML document the document may refer to external 
data. This occurs in three places: external parameter entities, normal 
external entities and the <CODE>DOCTYPE</CODE> declaration. The current 
version of this tool deals rather primitively with external data. 
External entities can only be loaded from a file and the mapping between 
the entity names and the file is done using a <EM>catalog</EM> file in a 
format compatible with that used by James Clark's SP Parser, based on 
the SGML Open (now OASIS) specification.

<P>Catalog files can be specified using two primitives: the predicate
<A NAME="idx:sgmlregistercatalogfile2:40"></A><A class="pred" href="#sgml_register_catalog_file/2">sgml_register_catalog_file/2</A> 
or the environment variable
<CODE>SGML_CATALOG_FILES</CODE> (compatible with the SP package).

<DL class="latex">
<DT class="pubdef"><A NAME="sgml_register_catalog_file/2"><STRONG>sgml_register_catalog_file</STRONG>(<VAR>+File, 
+Location</VAR>)</A></DT>
<DD class="defbody">
Register the indicated <VAR>File</VAR> as a catalog file. <VAR>Location</VAR> 
is either <CODE>start</CODE> or <CODE>end</CODE> and defines whether the 
catalog is considered first or last. This predicate has no effect if <VAR>File</VAR> 
is already part of the catalog.

<P>If no files are registered using this predicate, the first query on 
the catalog examines <CODE>SGML_CATALOG_FILES</CODE> and fills the 
catalog with all files in this path.
</DD>
</DL>

<P>Two types of lines are used by this package.
<BLOCKQUOTE>
<CODE>DOCTYPE</CODE> <VAR>doctype</VAR> <VAR>file</VAR> <BR>
<CODE>PUBLIC</CODE> <CODE>"</CODE><VAR>Id</VAR><CODE>"</CODE> <VAR>file</VAR>
</BLOCKQUOTE>

<P>The specified <VAR>file</VAR> path is taken relative to the location 
of the catolog file. For the <CODE>DOCTYPE</CODE> declaraction, <CODE>library(sgml)</CODE> 
first makes an attempt to resolve the <CODE>SYSTEM</CODE> or <CODE>PUBLIC</CODE> 
identifier. If this fails it tries to resolve the <VAR>doctype</VAR> 
using the provided catalog files.

<P>Strictly speaking, <CODE>library(sgml)</CODE> breaks the rules for 
XML, where system identifiers must be Universal Resource Indicators, not 
local file names. Simple uses of relative URIs will work correctly under 
UNIX and Windows.

<P>In the future we will design a call-back mechanism for locating and 
processing external entities, so Prolog-based file-location and Prolog 
resources can be used to store external entities.

<H2><A NAME="sec:8"><SPAN class="sec-nr">8</SPAN> <SPAN class="sec-title">library(pwp): 
Prolog Well-formed Pages</SPAN></A></H2>

<P><A NAME="sec:pwp"></A>

<DL>
<DT><B>author</B><DD> Richard O'Keefe
<DT><B>To be done</B><DD> Support compilation of PWP input files
</DL>

<P>PWP is an approach to server-side scripting using Prolog which is 
based on a simple key principle:

<P>
<UL class="latex">
<LI>The source form of a PWP should be WELL-FORMED XML
</UL>

<P>Especially when generating XML rather than HTML, this is such an 
obvious thing to do. We have many kinds of XML checking tools.

<P>
<UL class="latex">
<LI>We can tell whether an XML document is WELL FORMED (all the 
punctuation is right, all tags balance) using practically any decent 
parser, including SWI Prolog's 'sgml'.
<LI>If we can write a Document Type Description then we can check that a 
document is VALID using tools like Open SP (formerly James Clark's SP) 
or SWI Prolog's 'sgml'. This does not guarantee that the output will be 
valid, but it does catch a lot of errors very early.
<LI>If we can write an XML Schema then we can check that a document is 
schema-valid. (SWI Prolog's 'sgml' does not yet come with a schema 
validator, but who knows what the future holds?).
<LI>Since an XML document is just a data structure, we can use any 
checking tool that we can write in Prolog, IF the input is well-formed 
so that we can load a template as a Prolog data structure.
</UL>

<P>Having decided that the input should be well formed, that means
<B>NO NEW SYNTAX</B>

<P>None of the weird and horrible <VAR>&lt;</VAR>% ... %<VAR>&gt;</VAR> 
or whatever not-quite-XML stuff you see in other template systems, 
making checking so very hard (and therefore, making errors so 
distressingly common).

<P>That in turns means that PWP "markup" must be based on special 
elements or special attributes. The fact that an XML parser must allow 
undeclared attributes on any element even when validating, but must not 
allow undeclared elements, suggests doing this through attributes. In 
particular, one should be able to take an existing DTD, such as an XHTML 
DTD, and just use that without modification. So the design reduces to

<P>
<UL class="latex">
<LI>Allow dynamic data selection, insertion, and transformation just 
using a small number of extra attributes.
</UL>

<P>This description uses the following name space:

<PRE class="code">
xmlns:pwp='http://www.cs.otago.ac.nz/staffpriv/ok/pwp.pl'
</PRE>

<P>The attributes are

<P>
<UL COMPACT>
<LI>pwp:ask = Query
<LI>pwp:use = Term
<LI>pwp:how = text <CODE>|</CODE> xml
<LI>pwp:tag = QName or '-'
<LI>pwp:att = '' <CODE>|</CODE> 'one non-alphanumeric character'
</UL>

<P>Here's what they mean. Each element is expanded in the context of a 
set of variable bindings. After expansion, if the tag is not mapped to 
'-', all attributes in the pwp: namespace are removed and the children 
elements are recursively expanded.

<P>
<UL class="latex">
<LI>pwp:ask = Query

<P>
<UL class="latex">
<LI>Query is a Prolog goal. For each solution of Query, the element is 
further processed with the new variables of Query added to the context.
<LI>If Query is not a well formed Prolog goal, or if execution of Query 
throws an exception, page transformation comes to a complete halt and no 
page is generated.
</UL>

<P>
<LI>pwp:use = Term
<LI>pwp:how = text <CODE>|</CODE> xml <CODE>|</CODE> text-file <CODE>|</CODE> 
xml-file
<BLOCKQUOTE> Term is a Prolog term; variables in Term are bound by the 
context. An empty Term is regarded as a missing value for this 
attribute. The Prolog variable CONTEXT refers to the entire context, a 
list of Name = Value, where Name is a Prolog atom holding the name of 
the context variable and Value is an arbitrary Prolog term.
</BLOCKQUOTE>

<P>
<UL class="latex">
<LI>If pwp:how is text, The value of Term is used to define a sequence 
of characters.

<P>
<UL class="latex">
<LI>A number produces the same characters that <SPAN class="pred-ext">write/1</SPAN> 
would.
<LI>An atom produces the same characters that <SPAN class="pred-ext">write/1</SPAN> 
would.
<LI>A string produces the same characters that <SPAN class="pred-ext">write/1</SPAN> 
would.
<LI>A list of character codes produces those characters.
<LI>The following terms produce the same sequence of characters that the 
corresponding goal would have sent to the current output stream:

<DL class="latex">
<DT><STRONG>write</STRONG>(<VAR>Datum</VAR>)
<DT><STRONG>writeq</STRONG>(<VAR>Datum</VAR>)
<DT><STRONG>write_canonical</STRONG>(<VAR>Datum</VAR>)
<DT><STRONG>print</STRONG>(<VAR>Datum</VAR>)
<DT><STRONG>print</STRONG>(<VAR>Datum</VAR>)
<DT><STRONG>format</STRONG>(<VAR>Format</VAR>)
<DT><STRONG>format</STRONG>(<VAR>Format, Arguments</VAR>)</DT>
<DD class="defbody">
</DD>
</DL>

<P>
<LI>A singleton list [X] defines the characters that X defines.
<LI>Any other term F(T1,...,Tn) defines the characters that T1 defines, 
followed by the characters that T2 defines, ..., followed by the 
characters that Tn defines.
</UL>

<P>
<LI>If pwp:how is xml,
<BLOCKQUOTE> The value of Term must be an XML term as defined in the 
SGML2PL documentation or a list of such terms. A single term is taken as 
if it had been [Term]. The resulting list of terms replaces the children 
of the current element and will not be further processed.
</BLOCKQUOTE>

<P>
<LI>If pwp:how is text-file,
<BLOCKQUOTE> The value of Term is used to define a sequence of 
characters. That sequence of characters is used as a file name. The file 
is read as a sequence of characters, and that sequence used as character 
data.
</BLOCKQUOTE>

<P>
<LI>If pwp:how is xml-file,
<BLOCKQUOTE> The value of Term is used to define a sequence of 
characters. That sequence of characters is used as a file name. The file 
is loaded as XML, and the sequence of XML items thus obtained used. This 
means that PWP provides XML inclusion without depending on the parser to 
support XInclude.
</BLOCKQUOTE>

<P>The default value for pwp:how is text.
</UL>

<P>
<LI>pwp:tag = QName or '-'
<BLOCKQUOTE> If pwp:tag is missing or the value is empty, the current 
element appears in the output (after further processing) with its 
present tag. If pwp:tag is a QName, the current element appears (...) 
with that as its tag. That option is most useful in DTDs, where an 
"authoring" DTD may use one tag and have it automatically mapped to 
another tag in the output, e.g., <VAR>&lt;</VAR>item<VAR>&gt;</VAR> <CODE>-&gt;</CODE> <VAR>&lt;</VAR>li<VAR>&gt;</VAR>. 
Finally, if pwp:tag is '-', the children of the current element (either 
the result of pwp:use or the transformed original children, whichever 
applies) appear in the output but there is no element around them.
</BLOCKQUOTE>

<P>A missing or empty pwp:ask is just like pwp:ask = 'true'.
<LI>pwp:att = '' <CODE>|</CODE> 'one non-alphanumeric character'.
<BLOCKQUOTE> Attributes in the pwp namespace are not affected by this 
attribute. Such attributes are always stripped out and never substituted 
into.
</BLOCKQUOTE>
<BLOCKQUOTE> If pwp:att is missing or empty, attributes of the current 
element are copied over to the output unchanged.
</BLOCKQUOTE>
<BLOCKQUOTE> If pwp:att = 'c' for some non-alphanumeric character c, 
each attribute is examined for occurrences of c(...)c which are as short 
as possible. There is no one character which could be used every time, 
so you have to explicitly choose a substitution marker which is safe for 
the data you do not want to be altered. None of the pwp attributes are 
inherited, least of all this one.
</BLOCKQUOTE>
<BLOCKQUOTE> Text outside c(...)c groups is copied unchanged; text 
inside such a group is parsed as a Prolog term and treated as if by 
pwp:how = text.
</BLOCKQUOTE>
</UL>

<P>Examples:

<P>
<OL class="latex">
<LI><B>A "Hello World" like example</B>

<PRE class="code">
&lt;html
  xmlns:pwp="http://www.cs.otago.ac.nz/staffpriv/ok/pwp.pl"
  pwp:ask = "ensure_loaded(msg), once(msg(Greeting))"&gt;
  &lt;head&gt;
    &lt;title pwp:use="Greeting"/&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;&lt;span pwp:use="Greeting" pwp:tag='-'/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</PRE>

<P>where <CODE>msg.pl</CODE> contains

<PRE class="code">
msg('Hello, World!').
</PRE>

<P>This example illustrates an important point. Prolog Well-Formed Pages 
provide <B>NO</B> way to physically incorporate Prolog <B>clauses</B> 
into a page template. Prolog clauses must be put in separate files which 
can be checked by a Prolog syntax checker, compiler, cross-referencer, &amp;c 
WITHOUT the Prolog tool in question needing to know anything whatsoever 
about PWP. You load the files using pwp:ask on the root element.
<LI><B>Binding some variables and using them</B>

<PRE class="code">
&lt;html
  xmlns:pwp="http://www.cs.otago.ac.nz/staffpriv/ok/pwp.pl"&gt;
  &lt;head&gt;&lt;title&gt;Example 2&lt;/title&gt;&lt;/head&gt;
  &lt;body pwp:ask="Hello = 'Hello world', A = 20, B = 22"&gt;
    &lt;h1 pwp:use="Hello"/&gt;
    &lt;p&gt;The answer is &lt;span pwp:use="C" pwp:ask="C is A+B"/&gt;.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</PRE>

<P>
<LI><B>Making a table</B> We are given a Prolog database <CODE>staff.pl</CODE> 
defining staff(NickName, FullName, Office, Phone, E_Mail_Address). 
status(NickName, full_time <CODE>|</CODE> part_time). We want to make a 
phone list of full time staff.

<PRE class="code">
&lt;html
  xmlns:pwp="http://www.cs.otago.ac.nz/staffpriv/ok/pwp.pl"
  pwp:ask='ensure_loaded(staff)'&gt;
  &lt;head&gt;
    &lt;title&gt;Phone list for Full-Time staff.&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Phone list for Full-Time staff.&lt;/h1&gt;
    &lt;table
      pwp:ask = "setof(FullName-Phone,
                       N^O^E^(
                         status(N, full_time),
                         staff(N, FullName, O, Phone, E)
                       ),
                       Staff_List)"&gt;
      &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Phone&lt;/th&gt;&lt;/tr&gt;
      &lt;tr pwp:ask="member(FullName-Phone, Staff_List)"&gt;
        &lt;td pwp:use="FullName"/&gt;
        &lt;td pwp:use="Phone"/&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;
</PRE>

<P>
<LI><B>Substituting into an attribute</B> Same data base as before, but 
now we want to make a mailing list page.

<PRE class="code">
&lt;html
  xmlns:pwp="http://www.cs.otago.ac.nz/staffpriv/ok/pwp.pl"
  pwp:ask='ensure_loaded(staff)'&gt;
  &lt;head&gt;
    &lt;title&gt;Phone list for Full-Time staff.&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Phone list for Full-Time staff.&lt;/h1&gt;
    &lt;table
      pwp:ask = "setof(FullName-E_Mail,
                       N^O^P^staff(N, FullName, O, P, E_Mail),
                       Staff_List)"&gt;
      &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Address&lt;/th&gt;&lt;/tr&gt;
      &lt;tr pwp:ask="member(FullName-E_Mail, Staff_List)"&gt;
        &lt;td pwp:use="FullName"/&gt;
        &lt;td&gt;&lt;a pwp:use="E_Mail"
               pwp:att='$' href="mailto:$(E_Mail)$"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;
</PRE>

<P>
<LI><B>If-then-else effect</B> A page that displays the value of the 
'SHELL' environment variable if it has one, otherwise displays 'There is 
no default shell.'

<PRE class="code">
&lt;html
  xmlns:pwp="http://www.cs.otago.ac.nz/staffpriv/ok/pwp.pl"&gt;
  &lt;head&gt;&lt;title&gt;$SHELL&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;
    &lt;p pwp:ask="getenv('SHELL', Shell)"
    &gt;The default shell is &lt;span pwp:tag="-" pwp:use="Shell"/&gt;.&lt;/p&gt;
    &lt;p pwp:ask="\+getenv('SHELL',_)"&gt;There is no default shell.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</PRE>

<P>There is one other criterion for a good server-side template 
language:

<P>It should be possible to compile templates so as to eliminate most if 
not all interpretation overhead.

<P>This particular notation satisfies that criterion with the limitation 
that the conversion of a term to character data requires run-time 
traversal of terms (because the terms are not known until run time).
</OL>

<DL class="latex">
<DT class="pubdef"><span class="pred-tag">[det]</span><A NAME="pwp_files/2"><STRONG>pwp_files</STRONG>(<VAR>:In:atom, 
+Out:atom</VAR>)</A></DT>
<DD class="defbody">
loads an Xml document from the file named <VAR>In</VAR>, transforms it 
using the PWP attributes, and writes the transformed version to the new 
file named <VAR>Out</VAR>.</DD>
<DT class="pubdef"><span class="pred-tag">[det]</span><A NAME="pwp_stream/3"><STRONG>pwp_stream</STRONG>(<VAR>:Input:input_stream, 
+Output:output_stream, +Context:list</VAR>)</A></DT>
<DD class="defbody">
Loads an Xml document from the given <VAR>Input</VAR> stream, transforms 
it using the PWP attributes, and writes the transformed version to the 
given <VAR>Output</VAR> stream. <VAR>Context</VAR> provides initial 
contextual variables and is a list of Name=Value.</DD>
<DT class="pubdef"><A NAME="pwp_xml/3"><STRONG>pwp_xml</STRONG>(<VAR>:In:list(xml), 
-Out:list(xml), +Context</VAR>)</A></DT>
<DD class="defbody">
maps down a list of XML items, acting specially on elements and copying 
everything else unchanged, including white space. The <VAR>Context</VAR> 
is a list of 'VariableName'=CurrentValue bindings.
</DD>
</DL>

<H2><A NAME="sec:9"><SPAN class="sec-nr">9</SPAN> <SPAN class="sec-title">Writing 
markup</SPAN></A></H2>

<H3><A NAME="sec:9.1"><SPAN class="sec-nr">9.1</SPAN> <SPAN class="sec-title">Writing 
documents</SPAN></A></H3>

<P>The library <CODE>library(sgml_write)</CODE> provides the inverse of 
the parser, converting the parser's output back into a file. This 
process is fairly simple for XML, but due to the power of the SGML DTD 
it is much harder to achieve a reasonable generic result for SGML.

<P>These predicates can write the output in two encoding schemas 
depending on the encoding of the <VAR>Stream</VAR>. In UTF-8 mode, all 
characters are encoded using UTF-8 sequences. In ISO Latin-1 mode, 
characters outside the ISO Latin-1 range are represented using a named 
character entity if provided by the DTD or a numeric character entity.

<DL class="latex">
<DT class="pubdef"><A NAME="xml_write/3"><STRONG>xml_write</STRONG>(<VAR>+Stream, 
+Term, +Options</VAR>)</A></DT>
<DD class="defbody">
Write the XML header with encoding information and the content of the 
document as represented by <VAR>Term</VAR> to <VAR>Stream</VAR>. This 
predicate deals with XML with or without namespaces. If namespace 
identifiers are not provided they are generated. This predicate defines 
the following <VAR>Options</VAR>

<DL class="latex">
<DT><STRONG>dtd</STRONG>(<VAR>DTD</VAR>)</DT>
<DD class="defbody">
Specify the DTD. In SGML documents the DTD is required to distinguish 
between elements that are declared empty in the DTD and elements that 
just happen to have no content. Further optimisation (shortref, omitted 
tags, etc.) could be considered in the future. The DTD is also used to 
find the declared named character entities.
</DD>
<DT><STRONG>doctype</STRONG>(<VAR>Doctype</VAR>)</DT>
<DD class="defbody">
Document type to include in the header. When omitted it is taken from 
the outer element.
</DD>
<DT><STRONG>header</STRONG>(<VAR>Bool</VAR>)</DT>
<DD class="defbody">
If <VAR>Bool</VAR> is <CODE>false</CODE>, the XML header is suppressed. 
Useful for embedding in other XML streams.
</DD>
<DT><STRONG>layout</STRONG>(<VAR>Bool</VAR>)</DT>
<DD class="defbody">
Do/do not emit layout characters to make the output readable, Default is 
to emit layout. With layout enabled, elements only containing other 
elements are written using increasing indentation. This introduces 
(depending on the mode and defined whitespace handling) CDATA sequences 
with only layout between elements when read back in. If <CODE>false</CODE>, 
no layout characters are added. As this mode does not need to analyse 
the document it is faster and guarantees correct output when read back. 
Unfortunately the output is hardly human readable and causes problems 
with many editors.
</DD>
<DT><STRONG>indent</STRONG>(<VAR>Integer</VAR>)</DT>
<DD class="defbody">
Set the initial element indentation. It more than zero, the indent is 
written before the document.
</DD>
<DT><STRONG>nsmap</STRONG>(<VAR>Map</VAR>)</DT>
<DD class="defbody">
Set the initial namespace map. <VAR>Map</VAR> is a list of
<VAR>Name</VAR> = <VAR>URI</VAR>. This option, together with <CODE>header</CODE> 
and
<CODE>ident</CODE> is added to use <A NAME="idx:xmlwrite3:41"></A><A class="pred" href="#xml_write/3">xml_write/3</A> 
to generate XML that is embedded in a larger XML document.
</DD>
<DT><STRONG>net</STRONG>(<VAR>Bool</VAR>)</DT>
<DD class="defbody">

<P>Use/do not use <EM>Null End Tags</EM>. For XML, this applies only to 
empty elements, so you get <CODE>&lt;foo/&gt;</CODE> (default,
<CODE>net(true)</CODE>) or <CODE>\bnfmeta{foo}&lt;/foo&gt;</CODE> (<CODE>net(false)</CODE>). 
For SGML, this applies to empty elements, so you get <CODE>\bnfmeta{foo}</CODE> 
(if foo is declared to be <CODE>EMPTY</CODE> in the DTD),
<CODE>\bnfmeta{foo}&lt;/foo&gt;</CODE> (default, <CODE>net(false)</CODE>) 
or
<CODE>&lt;foo//</CODE> (<CODE>net(true)</CODE>). In SGML code, short 
character content not containing <CODE>/</CODE> can be emitted as <CODE>\bnfmeta{b}xxx&lt;/b&gt;</CODE> 
(default, <CODE>net(false)</CODE> or <CODE>&lt;b/xxx/</CODE> (<CODE>net(true)</CODE>)
</DD>
</DL>

</DD>
<DT class="pubdef"><A NAME="sgml_write/3"><STRONG>sgml_write</STRONG>(<VAR>+Stream, 
+Term, +Options</VAR>)</A></DT>
<DD class="defbody">
Write the SGML <CODE>DOCTYPE</CODE> header and the content of the 
document as represented by <VAR>Term</VAR> to <VAR>Stream</VAR>. The <VAR>Options</VAR> 
are described with <A NAME="idx:xmlwrite3:42"></A><A class="pred" href="#xml_write/3">xml_write/3</A>.</DD>
<DT class="pubdef"><A NAME="html_write/3"><STRONG>html_write</STRONG>(<VAR>+Stream, 
+Term, +Options</VAR>)</A></DT>
<DD class="defbody">
Same as <A NAME="idx:sgmlwrite3:43"></A><A class="pred" href="#sgml_write/3">sgml_write/3</A>, 
but passes the HTML DTD as obtained from <A NAME="idx:dtd2:44"></A><A class="pred" href="#dtd/2">dtd/2</A>. 
The <VAR>Options</VAR> are described with
<A NAME="idx:xmlwrite3:45"></A><A class="pred" href="#xml_write/3">xml_write/3</A>.
</DD>
</DL>

<H3><A NAME="sec:9.2"><SPAN class="sec-nr">9.2</SPAN> <SPAN class="sec-title">XML 
Quote primitives</SPAN></A></H3>

<P>In most cases, the preferred way to create an XML document is to 
create a Prolog tree of <CODE>element(Name, Attributes, Content)</CODE> 
terms and call <A NAME="idx:xmlwrite3:46"></A><A class="pred" href="#xml_write/3">xml_write/3</A> 
to write this to a stream. There are some exceptions where one might not 
want to pay the price of the intermediate representation. For these 
cases, this library contains building blocks for emitting markup data. 
The quote funtions return a version of the input text into one that 
contains entities for characters that need to be escaped. These are the 
XML meta characters and the characters that cannot be expressed by the 
document encoding. Therefore these predicates accept an <VAR>encoding</VAR> 
argument. Accepted values are <CODE>ascii</CODE>,
<CODE>iso_latin_1</CODE>, <CODE>utf8</CODE> and <CODE>unicode</CODE>. 
Versions with two arguments are provided for backward compatibility, 
making the safe
<CODE>ascii</CODE> encoding assumption.

<DL class="latex">
<DT class="pubdef"><A NAME="xml_quote_attribute/3"><STRONG>xml_quote_attribute</STRONG>(<VAR>+In, 
-Quoted, +Encoding</VAR>)</A></DT>
<DD class="defbody">
Map the characters that may not appear in XML attributes to entities. 
Currently these are <CODE>&lt;&gt;&amp;"</CODE>.<SUP class="fn">3<SPAN class="fn-text">Older 
versions also mapped <TT>'</TT> to <TT>&amp;apos;</TT>.</SPAN></SUP> 
Characters that cannot represented in <VAR>Encoding</VAR> are mapped to 
XML character entities.</DD>
<DT class="pubdef"><A NAME="xml_quote_attribute/2"><STRONG>xml_quote_attribute</STRONG>(<VAR>+In, 
-Quoted</VAR>)</A></DT>
<DD class="defbody">
Backward compatibility version for <A NAME="idx:xmlquoteattribute3:47"></A><A class="pred" href="#xml_quote_attribute/3">xml_quote_attribute/3</A>. 
Assumes <CODE>ascii</CODE> encoding.</DD>
<DT class="pubdef"><A NAME="xml_quote_cdata/3"><STRONG>xml_quote_cdata</STRONG>(<VAR>+In, 
-Quoted, +Encoding</VAR>)</A></DT>
<DD class="defbody">
Very similar to <A NAME="idx:xmlquoteattribute3:48"></A><A class="pred" href="#xml_quote_attribute/3">xml_quote_attribute/3</A>, 
but does not quote the single- and double-quotes.</DD>
<DT class="pubdef"><A NAME="xml_quote_cdata/2"><STRONG>xml_quote_cdata</STRONG>(<VAR>+In, 
-Quoted</VAR>)</A></DT>
<DD class="defbody">
Backward compatibility version for <A NAME="idx:xmlquotecdata3:49"></A><A class="pred" href="#xml_quote_cdata/3">xml_quote_cdata/3</A>. 
Assumes <CODE>ascii</CODE> encoding.</DD>
<DT class="pubdef"><A NAME="xml_name/2"><STRONG>xml_name</STRONG>(<VAR>+In, 
+Encoding</VAR>)</A></DT>
<DD class="defbody">
Succeed if <VAR>In</VAR> is an atom or string that satisfies the rules 
for a valid XML element or attribute name. As with the other predicates 
in this group, if <VAR>Encoding</VAR> cannot represent one of the 
characters, this function fails. Character classification is based on
<A class="url" href="http://www.w3.org/TR/2006/REC-xml-20060816">http://www.w3.org/TR/2006/REC-xml-20060816</A>.</DD>
<DT class="pubdef"><A NAME="xml_name/1"><STRONG>xml_name</STRONG>(<VAR>+In</VAR>)</A></DT>
<DD class="defbody">
Backward compatibility version for <A NAME="idx:xmlname2:50"></A><A class="pred" href="#xml_name/2">xml_name/2</A>. 
Assumes <CODE>ascii</CODE> encoding.
</DD>
</DL>

<H2><A NAME="sec:10"><SPAN class="sec-nr">10</SPAN> <SPAN class="sec-title">Unsupported 
features</SPAN></A></H2>

<P>The current parser is rather limited. While it is able to deal with 
many serious documents, it omits several less-used features of SGML and 
XML. Known missing SGML features include

<P>
<UL class="latex">
<LI><I>NOTATION on entities</I><BR>
Though notation is parsed, notation attributes on external entity 
declarations are not handed to the user.
<LI><I>NOTATION attributes</I><BR>
SGML notations may have attributes, declared using
<CODE>&lt;!ATTLIST #NOTATION name attributes&gt;</CODE>. Those data 
attributes are provided when you declare an external CDATA, NDATA, or 
SDATA entity.

<P>XML does not include external CDATA, NDATA, or SDATA entities, nor 
any of the other uses to which data attributes are put in SGML, so it 
doesn't include data attributes for notations either.

<P>Sgml2pl does not support this feature and is unlikely to; you should 
be aware that SGML documents using this feature cannot be converted 
faithfully to XML.
<LI><I>SHORTTAG</I><BR>
The SGML SHORTTAG syntax is only partially implemented. Currently,
<CODE>&lt;tag/content/</CODE> is a valid abbreviation for
<CODE>\bnfmeta{tag}content&lt;/tag&gt;</CODE>, which can also be written 
as
<CODE>\bnfmeta{tag}content&lt;/&gt;</CODE>. Empty start tags (<CODE>&lt;&gt;</CODE>), 
unclosed start tags (<CODE>&lt;a&lt;b&lt;/verb&gt;) and unclosed end tags (\bnfmeta{verb}&lt;/a&lt;b</CODE>) 
are not supported.
<LI><I>SGML declaration</I><BR>
The `SGML declaration' is fixed, though most of the parameters are 
handled through indirections in the implementation.
<LI><I>The DATATAG feature</I><BR>
It is regarded as superseeded by SHORTREF, which is supported. (SP does 
not support it either.)
<LI><I>The RANK feature</I><BR>
It is regarded as obsolete.
<LI><I>The LINK feature</I><BR>
It is regarded as too complicated.
<LI><I>The CONCUR feature</I><BR>
Concurrent markup allows a document to be tagged according to more than 
one DTD at the same time. It is not supported.
</UL>

<P>In XML mode the parser recognises SGML constructs that are not 
allowed in XML. Also various extensions of XML over SGML are not yet 
realised. In particular, XInclude is not implemented because the 
designers of XInclude can't make up their minds whether to base it on 
elements or attributes yet, let alone details.

<H2><A NAME="sec:11"><SPAN class="sec-nr">11</SPAN> <SPAN class="sec-title">Installation</SPAN></A></H2>

<H3><A NAME="sec:11.1"><SPAN class="sec-nr">11.1</SPAN> <SPAN class="sec-title">Unix 
systems</SPAN></A></H3>

<P>Installation on Unix system uses the commonly found <B>configure</B>,
<B>make</B> and <B>make install</B> sequence. SWI-Prolog should be 
installed before building this package. If SWI-Prolog is not installed 
as <B>pl</B>, the environment variable <CODE>PL</CODE> must be set to 
the name of the SWI-Prolog executable. Installation is now accomplished 
using:

<PRE class="code">
% ./configure
% make
% make install
</PRE>

<P>This installs the foreign libraries in <CODE>$PLBASE/lib/$PLARCH</CODE> 
and the Prolog library files in <CODE>$PLBASE/library</CODE>, where <CODE>$PLBASE</CODE> 
refers to the SWI-Prolog `home-directory'.

<H2><A NAME="sec:12"><SPAN class="sec-nr">12</SPAN> <SPAN class="sec-title">Acknowledgements</SPAN></A></H2>

<P>The Prolog representation for parsed documents is based on the 
SWI-Prolog interface to SP by Anjo Anjewierden.

<P>Richard O'Keefe has put a lot of effort testing and providing bug 
reports consisting of an illustrative example and explanation of the 
standard. He also made many suggestions for improving this document.

<H1><A NAME="document-index">Index</A></H1>

<DL>
<DT><STRONG>D</STRONG>
<DT><A class="idx" href="#dtd/2">dtd/2</A></DT>
<DD>
<A class="idx" href="#idx:dtd2:3">2.1</A> <A class="idx" href="#idx:dtd2:4">2.1</A> <A class="idx" href="#idx:dtd2:44">9.1</A></DD>
<DT><A class="idx" href="#dtd_property/2">dtd_property/2</A></DT>
<DD>
<A class="idx" href="#idx:dtdproperty2:24">3.6</A></DD>
<DT><STRONG>F</STRONG>
<DT><A class="idx" href="#free_dtd/1">free_dtd/1</A>
<DT><A class="idx" href="#free_sgml_parser/1">free_sgml_parser/1</A>
<DT><STRONG>G</STRONG>
<DT><A class="idx" href="#get_sgml_parser/2">get_sgml_parser/2</A></DT>
<DD>
<A class="idx" href="#idx:getsgmlparser2:27">3.6</A> <A class="idx" href="#idx:getsgmlparser2:31">3.6</A> <A class="idx" href="#idx:getsgmlparser2:32">3.6</A></DD>
<DT><STRONG>H</STRONG>
<DT><A class="idx" href="#html_write/3">html_write/3</A>
<DT><STRONG>I</STRONG>
<DT><A class="idx" href="#iri_xml_namespace/2">iri_xml_namespace/2</A>
<DT><A class="idx" href="#iri_xml_namespace/3">iri_xml_namespace/3</A></DT>
<DD>
<A class="idx" href="#idx:irixmlnamespace3:14">3.3.1</A> <A class="idx" href="#idx:irixmlnamespace3:16">3.3.1</A></DD>
<DT><STRONG>L</STRONG>
<DT><A class="idx" href="#load_dtd/2">load_dtd/2</A></DT>
<DD>
<A class="idx" href="#idx:loaddtd2:20">3.4</A></DD>
<DT><A class="idx" href="#load_dtd/3">load_dtd/3</A></DT>
<DD>
<A class="idx" href="#idx:loaddtd3:17">3.4</A></DD>
<DT><A class="idx" href="#load_html_file/2">load_html_file/2</A></DT>
<DD>
<A class="idx" href="#idx:loadhtmlfile2:2">2.1</A> <A class="idx" href="#idx:loadhtmlfile2:8">3.1</A></DD>
<DT><A class="idx" href="#load_sgml_file/2">load_sgml_file/2</A></DT>
<DD>
<A class="idx" href="#idx:loadsgmlfile2:6">3.1</A></DD>
<DT>load_structure/2</DT>
<DD>
<A class="idx" href="#idx:loadstructure2:25">3.6</A> <A class="idx" href="#idx:loadstructure2:26">3.6</A> <A class="idx" href="#idx:loadstructure2:34">3.6.1</A></DD>
<DT><A class="idx" href="#load_structure/3">load_structure/3</A></DT>
<DD>
<A class="idx" href="#idx:loadstructure3:1">2.1</A> <A class="idx" href="#idx:loadstructure3:5">3.1</A> <A class="idx" href="#idx:loadstructure3:10">3.1</A> <A class="idx" href="#idx:loadstructure3:11">3.2</A></DD>
<DT><A class="idx" href="#load_xml_file/2">load_xml_file/2</A></DT>
<DD>
<A class="idx" href="#idx:loadxmlfile2:7">3.1</A></DD>
<DT><STRONG>N</STRONG>
<DT><A class="idx" href="#new_dtd/2">new_dtd/2</A>
<DT><A class="idx" href="#new_sgml_parser/2">new_sgml_parser/2</A>
<DT><STRONG>O</STRONG>
<DT>open/4</DT>
<DD>
<A class="idx" href="#idx:open4:19">3.4</A></DD>
<DT><A class="idx" href="#open_dtd/3">open_dtd/3</A></DT>
<DD>
<A class="idx" href="#idx:opendtd3:18">3.4</A></DD>
<DT><STRONG>P</STRONG>
<DT>print_message/2</DT>
<DD>
<A class="idx" href="#idx:printmessage2:28">3.6</A> <A class="idx" href="#idx:printmessage2:29">3.6</A></DD>
<DT>print_message/3</DT>
<DD>
<A class="idx" href="#idx:printmessage3:33">3.6</A></DD>
<DT><A class="idx" href="#pwp_files/2">pwp_files/2</A>
<DT><A class="idx" href="#pwp_stream/3">pwp_stream/3</A>
<DT><A class="idx" href="#pwp_xml/3">pwp_xml/3</A>
<DT><STRONG>S</STRONG>
<DT>seek/4</DT>
<DD>
<A class="idx" href="#idx:seek4:38">6</A></DD>
<DT><A class="idx" href="#set_sgml_parser/2">set_sgml_parser/2</A></DT>
<DD>
<A class="idx" href="#idx:setsgmlparser2:9">3.1</A> <A class="idx" href="#idx:setsgmlparser2:12">3.2</A> <A class="idx" href="#idx:setsgmlparser2:13">3.3.1</A> <A class="idx" href="#idx:setsgmlparser2:23">3.6</A> <A class="idx" href="#idx:setsgmlparser2:37">4</A></DD>
<DT><A class="idx" href="#sgml_parse/2">sgml_parse/2</A></DT>
<DD>
<A class="idx" href="#idx:sgmlparse2:21">3.6</A> <A class="idx" href="#idx:sgmlparse2:22">3.6</A> <A class="idx" href="#idx:sgmlparse2:30">3.6</A> <A class="idx" href="#idx:sgmlparse2:35">3.6.1</A> <A class="idx" href="#idx:sgmlparse2:39">6</A></DD>
<DT><A class="idx" href="#sgml_register_catalog_file/2">sgml_register_catalog_file/2</A></DT>
<DD>
<A class="idx" href="#idx:sgmlregistercatalogfile2:40">7</A></DD>
<DT><A class="idx" href="#sgml_write/3">sgml_write/3</A></DT>
<DD>
<A class="idx" href="#idx:sgmlwrite3:43">9.1</A></DD>
<DT><STRONG>X</STRONG>
<DT><A class="idx" href="#xml_is_dom/1">xml_is_dom/1</A>
<DT><A class="idx" href="#xml_name/1">xml_name/1</A>
<DT><A class="idx" href="#xml_name/2">xml_name/2</A></DT>
<DD>
<A class="idx" href="#idx:xmlname2:15">3.3.1</A> <A class="idx" href="#idx:xmlname2:50">9.2</A></DD>
<DT><A class="idx" href="#xml_quote_attribute/2">xml_quote_attribute/2</A>
<DT><A class="idx" href="#xml_quote_attribute/3">xml_quote_attribute/3</A></DT>
<DD>
<A class="idx" href="#idx:xmlquoteattribute3:47">9.2</A> <A class="idx" href="#idx:xmlquoteattribute3:48">9.2</A></DD>
<DT><A class="idx" href="#xml_quote_cdata/2">xml_quote_cdata/2</A>
<DT><A class="idx" href="#xml_quote_cdata/3">xml_quote_cdata/3</A></DT>
<DD>
<A class="idx" href="#idx:xmlquotecdata3:49">9.2</A></DD>
<DT><A class="idx" href="#xml_write/3">xml_write/3</A></DT>
<DD>
<A class="idx" href="#idx:xmlwrite3:36">3.7</A> <A class="idx" href="#idx:xmlwrite3:41">9.1</A> <A class="idx" href="#idx:xmlwrite3:42">9.1</A> <A class="idx" href="#idx:xmlwrite3:45">9.1</A> <A class="idx" href="#idx:xmlwrite3:46">9.2</A></DD>
<DT><A class="idx" href="#xpath/3">xpath/3</A>
<DT><A class="idx" href="#xpath_chk/3">xpath_chk/3</A></DT>
<DD>
</DD>
</DL>

</BODY></HTML>